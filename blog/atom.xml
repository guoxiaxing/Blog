<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guoxiaxing.github.io/Blog/blog</id>
    <title>Try's Blog Blog</title>
    <updated>2021-12-20T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guoxiaxing.github.io/Blog/blog"/>
    <subtitle>Try's Blog Blog</subtitle>
    <icon>https://guoxiaxing.github.io/Blog/img/logo.jpeg</icon>
    <entry>
        <title type="html"><![CDATA[rxjs 操作符]]></title>
        <id>rxjs-operators</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/rxjs-operators"/>
        <updated>2021-12-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[条件]]></summary>
        <content type="html"><![CDATA[<h2>条件</h2><h3>every</h3><pre><code class="language-typescript">every(predicate: function, thisArg: any): Observable
</code></pre><p>类似于数组的 every 方法，判断流<strong>完成时</strong>发出的所有值是否满足传入的回调函数的条件，从而返回 true/false
如果<strong>完成时</strong>所有的值都能通过断言，那么发出 true，否则发出 false 。类似于数组的 every 方法</p><pre><code class="language-typescript">// RxJS v6+
import { every } from &quot;rxjs/operators&quot;;
import { of } from &quot;rxjs&quot;;

// 发出5个值
const source = of(1, 2, 3, 4, 5);
const example = source.pipe(
  // 每个值都是偶数吗？
  every(val =&gt; val % 2 === 0)
);
// 输出: false
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>defaultIfEmpty</h3><pre><code class="language-typescript">aultIfEmpty(defaultValue: any): Observable
</code></pre><p>如果流在<strong>完成</strong>时没有发出任何值，则发出 defaultIfEmpty 中的值</p><pre><code class="language-typescript">// RxJS v6+
import { defaultIfEmpty } from &quot;rxjs/operators&quot;;
import { of } from &quot;rxjs&quot;;

// 当源 observable 为空时，发出 &#x27;Observable.of() Empty!&#x27;，否则发出源的任意值
const exampleOne = of().pipe(defaultIfEmpty(&quot;Observable.of() Empty!&quot;));
// 输出: &#x27;Observable.of() Empty!&#x27;
const subscribe = exampleOne.subscribe(val =&gt; console.log(val));
</code></pre><h2>组合</h2><h3>combineLastest</h3><p>是一个 creator</p><pre><code class="language-typescript">combineLatest(observables: ...Observable, project: function): Observable
</code></pre><p>传入的 observables 都需要至少发出一个值，它才会发出值；然后就是任意一个 observable 发出值都会和其他的 observable 的最新值组合成一个数组发出。</p><p>发出的值是一个数组，数组的每个值时当前的所有 observable 的最新值，当最后一个 observable complete 的时候整体才会 complete</p><h4>使用场景</h4><p>当有多个长期活动的 observables 且它们依靠彼此来进行一些计算或决定时，此操作符是最适合的。</p><pre><code class="language-typescript">// RxJS v6+
import { timer, combineLatest } from &quot;rxjs&quot;;

// timerOne 在1秒时发出第一个值，然后每4秒发送一次
const timerOne = timer(1000, 4000);
// timerTwo 在2秒时发出第一个值，然后每4秒发送一次
const timerTwo = timer(2000, 4000);
// timerThree 在3秒时发出第一个值，然后每4秒发送一次
const timerThree = timer(3000, 4000);

// combineLatest 还接收一个可选的 projection 函数
const combinedProject = combineLatest(
  timerOne,
  timerTwo,
  timerThree,
  (one, two, three) =&gt; {
    return `Timer One (Proj) Latest: ${one},
              Timer Two (Proj) Latest: ${two},
              Timer Three (Proj) Latest: ${three}`;
  }
);
// 输出值
// 组合的结果在3s之后发出第一个值
const subscribe = combinedProject.subscribe(latestValuesProject =&gt;
  console.log(latestValuesProject)
);
</code></pre><h3>withLatestFrom</h3><p>是一个 operator，解决的问题：防止同源干扰</p><pre><code class="language-typescript">withLatestFrom(other: Observable, project: Function): Observable
</code></pre><p>还提供另一个 observable 的最新值。由源 observable 控制发出值的速率（当两个 observable 都发出值后），源 observable 每次发出值的时候，将源 observable 发出的值和 other 的最新值合并为一个数组发出
两个 observable 在发出值前要确保至少都有 1 个值，也就是说初始值需要等到两个 observable 都发出值。</p><p>发出的值时两个 observable 的最新值组成的数组</p><h4>源 observable 速率慢</h4><pre><code class="language-typescript">// RxJS v6+
import { withLatestFrom, map } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs&quot;;

// 每5秒发出值
const source = interval(5000);
// 每1秒发出值
const secondSource = interval(1000);
const example = source.pipe(
  withLatestFrom(secondSource),
  map(([first, second]) =&gt; {
    return `First Source (5s): ${first} Second Source (1s): ${second}`;
  })
);
/*
  输出:
  &quot;First Source (5s): 0 Second Source (1s): 4&quot;
  &quot;First Source (5s): 1 Second Source (1s): 9&quot;
  &quot;First Source (5s): 2 Second Source (1s): 14&quot;
  ...
*/
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h4>other 速率慢</h4><pre><code class="language-typescript">// RxJS v6+
import { withLatestFrom, map } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs&quot;;

// 每5秒发出值
const source = interval(5000);
// 每1秒发出值
const secondSource = interval(1000);
// withLatestFrom 的 observable 比源 observable 慢
const example = secondSource.pipe(
  // 两个 observable 在发出值前要确保至少都有1个值 (需要等待5秒)
  withLatestFrom(source),
  map(([first, second]) =&gt; {
    return `Source (1s): ${first} Latest From (5s): ${second}`;
  })
);
/*
  &quot;Source (1s): 4 Latest From (5s): 0&quot;
  &quot;Source (1s): 5 Latest From (5s): 0&quot;
  &quot;Source (1s): 6 Latest From (5s): 0&quot;
  ...
*/
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>zip</h3><pre><code class="language-typescript">zip(observables: *): Observable
</code></pre><p>将所有 observable 的第 i 个元素组成数组发出，发出第一个值的前提时所有 observable 都需要发出至少一个值。
任意一个 observable complete，则 zip 组合得到的 observable 就 complete
zip 操作符会订阅所有内部 observables，然后等待每个发出一个值。一旦发生这种情况，将发出具有相应索引的所有值。这会持续进行，直到至少一个内部 observable 完成。</p><blockquote><p>与 interval 或 timer 进行组合, zip 可以用来根据另一个 observable 进行定时输出！</p></blockquote><pre><code class="language-typescript">// RxJS v6+
import { take } from &quot;rxjs/operators&quot;;
import { interval, zip } from &quot;rxjs&quot;;

// 每1秒发出值
const source = interval(1000);
// 当一个 observable 完成时，便不会再发出更多的值了
const example = zip(source, source.pipe(take(2)));
// 输出: [0,0]...[1,1]
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>forkJoin</h3><pre><code class="language-typescript">forkJoin(...args, selector : function): Observable
</code></pre><p><strong>注意：接收的参数可以是一个数组，也可以是多个 observable，Promise.all 接收的是一个数组</strong></p><p>类似于 Promise.all，并发执行，结果是每个 observable 发出的最新值组合成的数组，<strong>需要等所有的 observable 都完成之后，将每个 observable 的最新值组成一个数组发出</strong>
⚠️<strong>如果内部 observable 不完成的话，forkJoin 永远不会发出值！</strong></p><h4>使用场景</h4><p>当有一组 observables，但你只关心每个 observable 最后发出的值时，此操作符是最适合的。此操作符的一个常见用例是在页面加载(或其他事件)时你希望发起多个请求，并在所有请求都响应后再采取行动。
注意，如果任意作用于 forkJoin 的内部 observable 报错的话，对于那些在内部 observable 上没有正确 catch 错误，从而导致完成的 observable 将丢失它们的值，<strong>即一个失败，整体失败</strong></p><h4>外部处理错误</h4><pre><code class="language-typescript">// RxJS v6+
import { delay, catchError } from &quot;rxjs/operators&quot;;
import { forkJoin, of, throwError } from &quot;rxjs&quot;;

/*
  当所有 observables 完成时，将每个 observable 
  的最新值作为数组发出
*/
const example = forkJoin(
  // 立即发出 &#x27;Hello&#x27;
  of(&quot;Hello&quot;),
  // 1秒后发出 &#x27;World&#x27;
  of(&quot;World&quot;).pipe(delay(1000)),
  // 抛出错误
  _throw(&quot;This will error&quot;)
).pipe(catchError(error =&gt; of(error)));
// 输出: &#x27;This will Error&#x27;
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h4>内部处理错误</h4><pre><code class="language-typescript">// RxJS v6+
import { delay, catchError } from &quot;rxjs/operators&quot;;
import { forkJoin, of, throwError } from &quot;rxjs&quot;;

/*
  当所有 observables 完成时，将每个 observable 
  的最新值作为数组发出
*/
const example = forkJoin(
  // 立即发出 &#x27;Hello&#x27;
  of(&quot;Hello&quot;),
  // 1秒后发出 &#x27;World&#x27;
  of(&quot;World&quot;).pipe(delay(1000)),
  // 抛出错误
  _throw(&quot;This will error&quot;).pipe(catchError(error =&gt; of(error)))
);
// 输出: [&quot;Hello&quot;, &quot;World&quot;, &quot;This will error&quot;]
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>race</h3><pre><code class="language-typescript">race(...args): Observable
</code></pre><p><strong>注意：接收的参数可以是一个数组，也可以是多个 observable，Promise.race 接收的是一个数组</strong></p><p>类似于 Promise.race
使用首先发出值的 observable 。无论他的状态是什么</p><pre><code class="language-typescript">// RxJS v6+
import { mapTo } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs/observable/interval&quot;;
import { race } from &quot;rxjs/observable/race&quot;;

// 接收第一个发出值的 observable
const example = race(
  // 每1.5秒发出值
  interval(1500),
  // 每1秒发出值
  interval(1000).pipe(mapTo(&quot;1s won!&quot;)),
  // 每2秒发出值
  interval(2000),
  // 每2.5秒发出值
  interval(2500)
);
// 输出: &quot;1s won!&quot;...&quot;1s won!&quot;...etc
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><pre><code class="language-typescript">// RxJS v6+
import { delay, map } from &quot;rxjs/operators&quot;;
import { of, race } from &quot;rxjs&quot;;

// 抛出错误并忽略其他的 observables 。
const first = of(&quot;first&quot;).pipe(
  delay(100),
  map(_ =&gt; {
    throw &quot;error&quot;;
  })
);
const second = of(&quot;second&quot;).pipe(delay(200));
const third = of(&quot;third&quot;).pipe(delay(300));
// error
race(first, second, third).subscribe(
  val =&gt; console.log(val),
  err =&gt; console.log(err)
);
</code></pre><h3>pairwise()</h3><pre><code class="language-typescript">pairwise(): Observable&lt;Array&gt;
</code></pre><p>将前一个值和当前值组成的数组发出，所以第一个值发出的时候上游的 observable 已经发出了两个值</p><pre><code class="language-typescript">// RxJS v6+
import { pairwise, take } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs&quot;;

// 返回: [0,1], [1,2], [2,3], [3,4], [4,5]
// [0, 1] 在两秒后发出，后面的值则是每隔一秒发出
interval(1000)
  .pipe(pairwise(), take(5))
  .subscribe(console.log);
</code></pre><h3>concat()</h3><pre><code class="language-typescript">concat(observable1,observable2,....)
</code></pre><p>将多个 observables 转换成单个 observable 。
把传入的每一个 observable 串联起来，依次订阅。</p><p><strong>按照顺序，前一个 observable 完成了再订阅下一个 observable 并发出值。当前一个 observable 没有完成的时候，后面的 observable 永远不会被订阅</strong></p><p>与 concatAll 的区别是，concatAll 是一个 observable 里面又包裹了一个或者多个 observable，然后依次订阅 observable 里面包裹的 observable，它不接受参数，相当于，去掉一层 observable 然后对里面的 observables 进行 concat 操作</p><h4>作为操作符</h4><pre><code class="language-typescript">// RxJS v6+
import { concat } from &quot;rxjs/operators&quot;;
import { of } from &quot;rxjs&quot;;

// 发出 1,2,3
const sourceOne = of(1, 2, 3);
// 发出 4,5,6
const sourceTwo = of(4, 5, 6);
// 先发出 sourceOne 的值，当完成时订阅 sourceTwo
const example = sourceOne.pipe(concat(sourceTwo));
// 输出: 1,2,3,4,5,6
const subscribe = example.subscribe(val =&gt;
  console.log(&quot;Example: Basic concat:&quot;, val)
);
</code></pre><h4>作为 creator</h4><pre><code class="language-typescript">// RxJS v6+
import { of, concat } from &quot;rxjs&quot;;

// 发出 1,2,3
const sourceOne = of(1, 2, 3);
// 发出 4,5,6
const sourceTwo = of(4, 5, 6);

// 作为静态方法使用
const example = concat(sourceOne, sourceTwo);
// 输出: 1,2,3,4,5,6
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>merge()</h3><pre><code class="language-typescript">merge(input: Observable): Observable
</code></pre><p>将多个 observables 转换成单个 observable 。
用法和 concat 类似，区别就是 concat 是顺序的，merge 则是按照合并的 observable 发出值的顺序将值发出，所有 observable 一起执行</p><h4>作为 operator</h4><pre><code class="language-typescript">// RxJS v6+
import { merge } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs&quot;;

// 每2.5秒发出值
const first = interval(2500);
// 每1秒发出值
const second = interval(1000);
// 作为实例方法使用
const example = first.pipe(merge(second));
// 输出: 0,1,0,2....
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h4>作为 creator</h4><pre><code class="language-typescript">// RxJS v6+
import { mapTo } from &quot;rxjs/operators&quot;;
import { interval, merge } from &quot;rxjs&quot;;

// 每2.5秒发出值
const first = interval(2500);
// 每2秒发出值
const second = interval(2000);
// 每1.5秒发出值
const third = interval(1500);
// 每1秒发出值
const fourth = interval(1000);

// 从一个 observable 中发出输出值
const example = merge(
  first.pipe(mapTo(&quot;FIRST!&quot;)),
  second.pipe(mapTo(&quot;SECOND!&quot;)),
  third.pipe(mapTo(&quot;THIRD&quot;)),
  fourth.pipe(mapTo(&quot;FOURTH&quot;))
);
// 输出: &quot;FOURTH&quot;, &quot;THIRD&quot;, &quot;SECOND!&quot;, &quot;FOURTH&quot;, &quot;FIRST!&quot;, &quot;THIRD&quot;, &quot;FOURTH&quot;
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>concatAll()</h3><pre><code class="language-typescript">concatAll(): Observable
</code></pre><h4>打平 observable</h4><pre><code class="language-typescript">// RxJS v6+
import { map, concatAll } from &quot;rxjs/operators&quot;;
import { of, interval } from &quot;rxjs&quot;;

// 每2秒发出值
const source = interval(2000);
const example = source.pipe(
  // 为了演示，增加10并作为 observable 返回
  // source 每次发出值都会被转换为一个observable(value+10)如果没有concatAll，则subscribe打印出的则是一个observable
  map(val =&gt; of(val + 10)),
  // 合并内部 observables 的值
  concatAll()
);
// 输出: &#x27;Example with Basic Observable 10&#x27;, &#x27;Example with Basic Observable 11&#x27;...
const subscribe = example.subscribe(val =&gt;
  console.log(&quot;Example with Basic Observable:&quot;, val)
);
</code></pre><h4>依次订阅 observable</h4><pre><code class="language-typescript">// RxJS v6+
import { interval, of } from &quot;rxjs&quot;;
import { take, concatAll } from &quot;rxjs/operators&quot;;

const obs1 = interval(1000).pipe(take(5));
const obs2 = interval(500).pipe(take(2));
const obs3 = interval(2000).pipe(take(1));
// 发出3个 observables
const source = of(obs1, obs2, obs3);
// 按顺序订阅每个内部 obserable，前一个完成了再订阅下一个
const example = source.pipe(concatAll());
/*
  输出: 0,1,2,3,4,0,1,0
  怎么运行的...
  订阅每个内部 observable 并发出值，当一个完成了才订阅下一个
  obs1: 0,1,2,3,4 (complete)
  obs2: 0,1 (complete)
  obs3: 0 (complete)
*/

const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h3>mergeAll()</h3><pre><code class="language-typescript">mergeAll(concurrent: number): Observable
</code></pre><p>类似于 concatAll，打平外层的 observable，使用 merge 的方式合并内部的 observables 为单个 observable 来发出值
收集并订阅所有的 observables 。</p><h4>并发控制的 mergeAll</h4><pre><code class="language-typescript">// RxJS v6+
import { take, map, delay, mergeAll } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs&quot;;

const source = interval(500).pipe(take(5));

/*
  interval 每0.5秒发出一个值。这个值会被映射成延迟1秒的 interval 。mergeAll 操作符接收一个可选参数
  以决定在同一时间有多少个内部 observables 可以被订阅。其余的 observables 会先暂存以等待订阅。
*/
const example = source
  .pipe(
    map(val =&gt; source.pipe(delay(1000), take(3))),
    mergeAll(2)
  )
  .subscribe(val =&gt; console.log(val));
/*
  一旦操作符发出了所有值，则 subscription 完成。
*/
</code></pre><h3>startWith()</h3><pre><code class="language-typescript">startWith(an: Values): Observable
</code></pre><p>初始化流，给流一个初始值，也可以给多个初始值
发出给定的第一个值，该流立即发出我们给的值，类似于 BehaviorSubject</p><pre><code class="language-typescript">// RxJS v6+
import { startWith, scan } from &quot;rxjs/operators&quot;;
import { of } from &quot;rxjs&quot;;

// 发出 (&#x27;World!&#x27;, &#x27;Goodbye&#x27;, &#x27;World!&#x27;)
const source = of(&quot;World!&quot;, &quot;Goodbye&quot;, &quot;World!&quot;);
// 以 &#x27;Hello&#x27; 开头，后面接当前字符串
const example = source.pipe(
  startWith(&quot;Hello&quot;),
  scan((acc, curr) =&gt; `${acc} ${curr}`)
);
/*
  输出:
  &quot;Hello&quot;
  &quot;Hello World!&quot;
  &quot;Hello World! Goodbye&quot;
  &quot;Hello World! Goodbye World!&quot;
*/
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre><h4>可以初始化多个值</h4><pre><code class="language-typescript">// RxJS v6+
import { startWith } from &quot;rxjs/operators&quot;;
import { interval } from &quot;rxjs&quot;;

// 每1秒发出值
const source = interval(1000);
// 以 -3, -2, -1 开始
const example = source.pipe(startWith(-3, -2, -1));
// 输出: -3, -2, -1, 0, 1, 2....
const subscribe = example.subscribe(val =&gt; console.log(val));
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[rxjs 基础概念]]></title>
        <id>rxjs-basic</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/rxjs-basic"/>
        <updated>2021-12-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Rxjs 是什么？]]></summary>
        <content type="html"><![CDATA[<h2>Rxjs 是什么？</h2><p>RxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。</p><blockquote><p>可以把 RxJS 当做是用来处理事件的 Lodash。</p></blockquote><h2>特点</h2><ul><li>纯净性：使用纯函数来产生值，不需要借助外部变量</li><li>流动性：RxJS 提供了一整套操作符来帮助你控制事件如何流经 observables 。</li><li>值：可以对流经 observable 的值进行转换</li></ul><h2>Rxjs Observables vs Promise</h2><h3>多值 vs 单值</h3><p>一个 Promise 只能产生一个值/错误，之后的值或者错误都会被忽略。这也就是 Promise 的状态只能改变一次，一旦改变就不会再变。</p><pre><code class="language-javascript">const numberPromise = new Promise(resolve =&gt; {
  resolve(5);
  resolve(10); // 不生效
});

numberPromise.then(value =&gt; console.log(value));

// 输出 只会有 5
</code></pre><p>再看看 Observable</p><pre><code class="language-javascript">const Observable = require(&quot;rxjs/Observable&quot;).Observable;

const numberObservable = new Observable(observer =&gt; {
  observer.next(5);
  observer.next(10);
});

numberObservable.subscribe(value =&gt; console.log(value));

// 输出 5 10
</code></pre><p>Observable 是可以产生多个值的，这一点和 promise 的差别很大。平常我们可能遇到的大多数情况都是一个请求对应一个响应，但是我们也会有产生多个值的情况：</p><ul><li>定时器</li><li>DOM 事件</li></ul><h3>代码执行</h3><pre><code class="language-javascript">// Promise构造函数内部的逻辑是同步执行的
const promise = new Promise(resolve =&gt; {
  console.log(&quot;promise call&quot;);
  resolve(1);
  console.log(&quot;promise end&quot;);
});

// 执行这段代码 promise call 和 promise end 会立即执行
const observable = new Observable(() =&gt; {
  console.log(&quot;I was called!&quot;);
});

// 此时并没有console

// 只有 observable.subscribe(); 这个时候 I was called！才会被打印出来。
</code></pre><p>上面的代码我们可以发现 observable 是 lazy 的，只有在订阅的时候代码才会被执行</p><h3> 能取消 vs 不能取消</h3><p>promise 默认是不能取消的，一旦创建就会被执行。</p><pre><code class="language-javascript">const Observable = require(&quot;rxjs/Observable&quot;).Observable;

const observable = new Observable(observer =&gt; {
  let i = 0;
  const token = setInterval(() =&gt; {
    observer.next(i++);
  }, 1000);

  return () =&gt; clearInterval(token);
});

const subscription = observable.subscribe(value =&gt; console.log(value + &quot;!&quot;));

setTimeout(() =&gt; {
  subscription.unsubscribe();
}, 5000);

// 结果

// 0!
// 1!
// 2!
// 3!
</code></pre><p>observable 是可以被取消的，可以使用 subscribe 返回的值，一个 Subscription 对象的 unsubscribe 方法来取消订阅。</p><p><strong>new Observable 传入的函数的返回值会在 unsubscribe 调用的时候被执行，所以我们可以进行一些清理操作。需要注意的是我们取消的是对这个 observable 的订阅，但是原来的 new Observable 中的定时器依旧在执行，只是该定时器发的值，没有被订阅而已。所以我们需要执行<code>() =&gt; clearInterval(token)</code>清除该定时器</strong></p><h3>多个订阅 vs 单个订阅</h3><p>一个 promise 被创建的时候，他就已经执行了，并且不能重复的被执行了。</p><pre><code class="language-javascript">let time;
const waitOneSecondPromise = new Promise(resolve =&gt; {
  console.log(&quot;promise call&quot;);
  time = new Date().getTime();
  setTimeout(() =&gt; resolve(&quot;hello world&quot;), 1000);
});

waitOneSecondPromise.then(value =&gt; {
  console.log(&quot;第一次&quot;, value, new Date().getTime() - time);
});

setTimeout(() =&gt; {
  waitOneSecondPromise.then(value =&gt; {
    console.log(&quot;第二次&quot;, value, new Date().getTime() - time);
  });
}, 5000);

// 输出结果是 promise call
// 第一次 hello world 1007
// 第二次 hello world 5006
</code></pre><p>第一个 then 会在 1s 后输出值，第二个 then 会在 5s 后立即输出值，因为第二个 then 方法执行的时候 promise 的状态已经改变，所以它可以直接拿到 promise resolve 的值，不需要再等待 1s 了</p><p>observable：</p><pre><code class="language-javascript">const Observable = require(&quot;rxjs/Observable&quot;).Observable;

let time;
const waitOneSecondObservable = new Observable(observer =&gt; {
  console.log(&quot;I was called&quot;);
  time = new Date().getTime();
  setTimeout(() =&gt; observer.next(&quot;hey girl&quot;), 1000);
});

waitOneSecondObservable.subscribe(value =&gt; {
  console.log(&quot;第一次&quot;, value, new Date().getTime() - time);
});

setTimeout(() =&gt; {
  waitOneSecondObservable.subscribe(value =&gt; {
    console.log(&quot;第二次&quot;, value, new Date().getTime() - time);
  });
}, 5000);

// 输出
// I was called
// 第一次 hey girl 1003
// I was called
// 第二次 hey girl 1003
</code></pre><p>对于 observable，这里其实是(Cold Observable)他们每次被 subscribe 都是一次新的订阅，observable 会被重新执行。所以无论 observable 何时被 subscribe 产生的值都是一样的</p><p>但是有时候我们不希望每次 subscribe 都重新订阅，我们希望它可以共享前面的订阅，也就是不希望这个 observable 被重新在执行一遍，多用于 http 请求的场景。在 http 请求中，我们可能希望只发一次请求，但是结果被多个订阅者共用。 Observable 本身没有提供这个功能，我们可以用 RxJS 这个库来实现，它有一个 share 的 operator。其实这就是将一个 Cold Observable 变为了 Hot Observable。</p><pre><code class="language-javascript">const waitOneSecondObservable = new Observable(observer =&gt; {
  // 发送http请求
});

const sharedWaitOneSecondObservable = waitOneSecondObservable.share();

sharedWaitOneSecondObservable.subscribe(doSomething);

sharedWaitOneSecondObservable.subscribe(doSomethingElse);

// 使用了share，虽然subscribe了多次，但是仅发送一次请求，share了结果。
</code></pre><h3>可能是异步 vs 一直是异步</h3><p>promise 中同步的 resolve 了一个值，但是它还是会异步执行。</p><pre><code class="language-javascript">const promise = new Promise(resolve =&gt; {
  resolve(5);
});

promise.then(value =&gt; console.log(value + &quot;!&quot;));

console.log(&quot;And now we are here.&quot;);

// And now we are here.
// 5!
</code></pre><p>promise 一直是异步， Observables 则比较灵活，是否为异步得根据自己的函数来定，这点也比较危险。rxjs 中有一些操作符可以让监听强制为异步的方式，例如 observeOn。</p><pre><code class="language-javascript">const Observable = require(&quot;rxjs/Observable&quot;).Observable;

const observable = new Observable(observer =&gt; {
  observer.next(5);
  setTimeout(() =&gt; {
    observer.next(6);
  });
});

observable.subscribe(value =&gt; console.log(value + &quot;!&quot;));
console.log(&quot;And now we are here.&quot;);

// 5!
// And now we are here.
// 6!
</code></pre><h2>Observable</h2><p>可观察对象</p><ul><li><strong>可以是异步的，也可以是同步的</strong></li><li>是一个是多个值的惰性推送集合。可以产生值。</li><li>Observable 可以随着时间的推移 “返回” 多个值</li><li>在 Observable 执行中, 可能会发送零个到无穷多个 &quot;Next&quot; 通知。如果发送的是 &quot;Error&quot; 或 &quot;Complete&quot; 通知的话，那么之后不会再发送任何通知了。</li></ul><h3>Cold Observable</h3><p>单播的 observable
<strong>只有被 Observer 订阅了才会开始产生值。</strong>有多少个订阅就会生成多少个订阅的实例，每个订阅都是从第一个产生的值开始接收值，所以每个订阅接收到的值都是一样的。
每个普通的 Observables 实例都只能被一个观察者订阅，当它被其他观察者订阅的时候会产生一个新的实例。也就是普通 Observables 被不同的观察者订阅的时候，会有多个实例，不管观察者是从何时开始订阅，每个实例都是从头开始把值发给对应的观察者。</p><h3>Hot Observable</h3><p>不管有没有订阅都会产生值。是多播的，多个订阅会共享同一个实例。是从订阅开始接收值，每个订阅接收到的值都是不同的，取决于他们什么时候订阅。</p><h4>怎么创建 Hot Observable</h4><h5>multicast + Subject</h5><p>multicast 操作符的工作原理：观察者订阅一个基础的 Subject，然后 Subject 订阅源 Observable 。</p><pre><code class="language-javascript">var source = Rx.Observable.from([1, 2, 3]);
var subject = new Rx.Subject();
var multicasted = source.multicast(subject);

// 在底层使用了 `subject.subscribe({...})`:
multicasted.subscribe({
  next: v =&gt; console.log(&quot;observerA: &quot; + v)
});
multicasted.subscribe({
  next: v =&gt; console.log(&quot;observerB: &quot; + v)
});

// 在底层使用了 `source.subscribe(subject)`:
multicasted.connect();
</code></pre><p>multicast 返回的是 ConnectableObservable，它只是一个有 connect() 方法的 Observable 。</p><p>connect() 方法十分重要，它决定了何时启动共享的 Observable 执行。因为 connect() 方法在底层执行了 source.subscribe(subject)，所以它返回的是 Subscription，你可以取消订阅以取消共享的 Observable 执行。</p><blockquote><p>ConnectableObservable: ConnectableObservable 是多播的共享 Observable，可以同时被多个 observers 共享订阅，它是 Hot Observables。ConnectableObservable 是订阅者和真正的源头 Observables 的中间人，ConnectableObservable 从源头 Observables 接收到值然后再把值转发给订阅者。</p></blockquote><h5>refCount()</h5><p>ConnectableObservable 的 refCount() 方法(引用计数)，这个方法返回 Observable，这个 Observable 会追踪有多少个订阅者。当订阅者的数量从 0 变成 1，它会调用 connect() 以开启共享的执行。当订阅者数量从 1 变成 0 时，它会完全取消订阅，停止进一步的执行。</p><p><strong>refCount 的作用是，当有第一个订阅者时，多播 Observable 会自动地启动执行，而当最后一个订阅者离开时，多播 Observable 会自动地停止执行。</strong></p><h5>publish()</h5><p>等价于 multicast(new Subject())</p><p>这个操作符可以将 cold observable 转换为 ConnectableObservable，而不需要我们使用的创建 Subject 实例</p><pre><code class="language-javascript">let obs$ = interval(1000).pipe(publish(), refCount());
</code></pre><p><strong>publish(xxx).refCount()在源 observable 完成的时候再出现订阅者时，不会重新订阅源 observable</strong></p><p><strong>重新订阅已完成的 observables</strong></p><p>综上所述，根据示例我们可以发现 publish 以及它的变种:</p><ul><li><p>当源 observable 完成时，负责多播基础结构的 subject 也会完成，而且这会阻止对源 observable 的重新订阅。</p></li><li><p>当 publish 和 publishBehavior 与 refCount 一起使用时，后来的订阅者只会收到 complete 通知，这似乎并不是我们想要的效果。</p></li><li><p>当 publishReplay 和 publishLast 与 refCount 一起使用时，后来的订阅者会收到预期的通知。</p></li></ul><p><strong>重新订阅未完成的 observable</strong></p><p>当对未完成的源 observable 使用 refCount 时，publish、publishBehavior 和 publishReplay 的行为都如预期一般（当订阅者的数量从 0 变成 1，它会调用 connect() 以开启共享的执行。当订阅者数量从 1 变成 0 时，它会完全取消订阅，停止进一步的执行），会重新订阅源 observable</p><ul><li>publishReplay vs publishBehavior</li></ul><p><strong>已完成的 ReplaySubject 将通知重放给后来的订阅者，所以 b 能收到重放的 next 通知和 complete 通知。但是 publishBehavior 在源 observable complete 之后，后面订阅的 observer 将不会再收到最新值</strong></p><h5>share()</h5><p>等价于 publish() + refCount()</p><p>但是，share 传给 multicast 的是工厂函数，这意味着在引用计数为 0 之后发生订阅的话，会创建一个新的 Subject 来订阅源 observable 。</p><pre><code class="language-javascript">let obs$ = interval(1000).pipe(share());
</code></pre><blockquote><p>publishReplay、shareReplay、publishBehavior、publishLast 都可以将单播的 Observable 转换为多播的 Observable，只不过底层使用了不同类型的 Subject</p></blockquote><p>与 share 类似， shareReplay 传给 multicast 操作符的也是 subject 的工厂函数。这意味着当重新订阅源 observable 时，会使用工厂函数来创建出一个新的 subject 。但是，只有<strong>当前一个被订阅 subject 未完成</strong>的情况下，工厂函数才会返回新的 subject 。</p><p>publishReplay 传给 multicast 操作符的是 ReplaySubject 实例，而不是工厂函数，这是影响行为不同的原因。</p><p>对调用了 publishReplay().refCount() 的 observable 进行重新订阅，subject 会一直重放它的可重放通知。但是，对调用了 shareReplay() 的 observable 进行重新订阅，行为未必如前者一样，如果 subject 还未完成，会创建一个新的 subject 。(如果 subject 已完成，则和 publishReplay().refCount()的效果相同，不会重新创建一个新的 subject)所以区别在于，使用调用了 shareReplay() 的 observable 的话，当引用计数归零时，如果 subject 还未完成的话，可重放的通知会被冲洗掉。</p><p><strong>publishReplay().refCount() vs shareReplay() 对于当前 subject 完成的情况</strong></p><pre><code class="language-javascript">function instrument&lt;T&gt;(source: Observable&lt;T&gt;) {
      return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
        console.log(&quot;source: subscribing&quot;);
        const subscription = source
          .pipe(tap((value) =&gt; console.log(`source: ${value}`)))
          .subscribe(observer);
        return () =&gt; {
          subscription.unsubscribe();
          console.log(&quot;source: unsubscribed&quot;);
        };
      }) as Observable&lt;T&gt;;
    }

    function observer&lt;T&gt;(name: string) {
      return {
        next: (value: T) =&gt; console.log(`observer ${name}: ${value}`),
        complete: () =&gt; console.log(`observer ${name}: complete`)
      };
    }
    const source = instrument(timer(100));
    const counted = source.pipe(shareReplay(1));
    const a = counted.subscribe(observer(&quot;a&quot;));
    setTimeout(() =&gt; a.unsubscribe(), 110);
    setTimeout(() =&gt; counted.subscribe(observer(&quot;b&quot;)), 120);
</code></pre><p>输出</p><pre><code class="language-text">source: subscribing
source: 0
observer a: 0
observer a: complete
source: unsubscribed
observer b: 0
observer b: complete
</code></pre><p><strong>publishReplay().refCount() vs shareReplay() 订阅未完成的 observable 情况</strong></p><pre><code class="language-javascript">const source = instrument(interval(1000));
const counted = source.pipe(publishReplay(1), refCount());
const a = counted.subscribe(observer(&quot;a&quot;));
setTimeout(() =&gt; a.unsubscribe(), 1100);
setTimeout(() =&gt; counted.subscribe(observer(&quot;b&quot;)), 2000);
</code></pre><p>输出</p><pre><code class="language-text">source: subscribing
source: 0
observer a: 0
source: unsubscribed
observer b: 0
source: subscribing
source: 0
observer b: 0
source: 1
observer b: 1
source: 2
observer b: 2
</code></pre><pre><code class="language-javascript">const source = instrument(interval(1000));
const counted = source.pipe(shareReplay(1));
const a = counted.subscribe(observer(&quot;a&quot;));
setTimeout(() =&gt; a.unsubscribe(), 1100);
setTimeout(() =&gt; counted.subscribe(observer(&quot;b&quot;)), 2000);
</code></pre><p>输出</p><pre><code class="language-text">source: subscribing
source: 0
observer a: 0
source: 1
observer b: 1
source: 2
observer b: 2
source: 3
observer b: 3
source: 4
observer b: 4
</code></pre><p><strong>对于 shareReplay 的话，并不会在订阅者为 0 的时候取消对源 observable 的订阅并且重新订阅</strong>
<strong>shareReplay 只会在源 observable complete 或 error 时才会取消订阅，当引用计数归零时，操作符不再取消源 observable 的订阅。</strong></p><ul><li>如果源 observable 报错，publishReplay().refCount() 返回的 observable 的任何后来订阅者都将收到错误。</li><li>但是，shareReplay 返回的 observable 的任何后来订阅者都将产生一个源 observable 的新订阅。</li></ul><p><strong>但是对于 share 来说，则总会在重新订阅的时候生成一个新的 subject，并且重新订阅源 observable，不论当前的 subject 是否完成</strong></p><pre><code class="language-javascript">function instrument&lt;T&gt;(source: Observable&lt;T&gt;) {
      return Observable.create((observer: Observer&lt;T&gt;) =&gt; {
        console.log(&quot;source: subscribing&quot;);
        const subscription = source
          .pipe(tap((value) =&gt; console.log(`source: ${value}`)))
          .subscribe(observer);
        return () =&gt; {
          subscription.unsubscribe();
          console.log(&quot;source: unsubscribed&quot;);
        };
      }) as Observable&lt;T&gt;;
    }

    function observer&lt;T&gt;(name: string) {
      return {
        next: (value: T) =&gt; console.log(`observer ${name}: ${value}`),
        complete: () =&gt; console.log(`observer ${name}: complete`)
      };
    }
    const source = instrument(timer(100));
    const counted = source.pipe(share());
    const a = counted.subscribe(observer(&quot;a&quot;));
    setTimeout(() =&gt; a.unsubscribe(), 110);
    setTimeout(() =&gt; counted.subscribe(observer(&quot;b&quot;)), 120);
</code></pre><p>输出</p><pre><code class="language-text">source: subscribing
source: 0
observer a: 0
source: unsubscribed
observer a: complete
source: subscribing
source: 0
observer b: 0
source: unsubscribed
observer b: complete
</code></pre><pre><code class="language-javascript">const source = instrument(interval(1000));
const counted = source.pipe(share());
const a = counted.subscribe(observer(&quot;a&quot;));
setTimeout(() =&gt; a.unsubscribe(), 1500);
setTimeout(() =&gt; counted.subscribe(observer(&quot;b&quot;)), 2000);
</code></pre><p>输出</p><pre><code class="language-text">source: 0
observer a: 0
source: unsubscribed
source: subscribing
source: 0
observer b: 0
source: 1
observer b: 1
source: 2
observer b: 2
</code></pre><h2>Observer</h2><p>观察者</p><h3>什么是观察者？</h3><p>定义对于 observable 该如何处理</p><p>观察者是 Observable 发送的值的消费者。观察者只是一组回调函数的集合，每个回调函数对应一种 Observable 发送的通知类型：next、error 和 complete 。</p><pre><code class="language-javascript">var observer = {
  next: x =&gt; console.log(&quot;Observer got a next value: &quot; + x),
  error: err =&gt; console.error(&quot;Observer got an error: &quot; + err),
  complete: () =&gt; console.log(&quot;Observer got a complete notification&quot;)
};
</code></pre><p>要使用观察者，需要把它提供给 Observable 的 subscribe 方法：</p><pre><code class="language-javascript">observable.subscribe(observer);
</code></pre><p><strong>观察者只是有三个回调函数的对象，每个回调函数对应一种 Observable 发送的通知类型。</strong>
观察者也可以是部分的</p><h2>Subscription</h2><p>订阅</p><p>当你订阅了 Observable，你会得到一个 Subscription ，<strong>它表示进行中的执行</strong>。只要调用 unsubscribe() 方法就可以取消执行。</p><h2>Subject</h2><p>主体。是一种特殊的 observable（Hot Observable），它允许将值多播给多个观察者，所以 Subject 是多播的，而普通的 Observables 是单播的(每个已订阅的观察者都拥有 Observable 的独立执行)。</p><ul><li><strong>每个 Subject 都是 Observable。</strong> -对于 Subject，你可以提供一个观察者并使用 subscribe 方法，就可以开始正常接收值。从观察者的角度而言，它无法判断 Observable 执行是来自普通的 Observable 还是 Subject 。</li></ul><p>在 Subject 的内部，subscribe 不会调用发送值的新执行。它只是将给定的观察者注册到观察者列表中。也就是说这个新的观察者并不一定能收到 Subject 发出的所有值，它可以收到的值取决于它何时订阅。</p><ul><li><p><strong>每个 Subject 都是观察者。</strong> Subject 是一个有如下方法的对象： next(v)、error(e) 和 complete() 。要给 Subject 提供新值，只要调用 next(theValue)，它会将值多播给已注册监听该 Subject 的观察者们。</p></li><li><p>Subject 不可重用：也就是说，当一个 Subject 完成或者出错时，就不能再使用了。</p></li></ul><pre><code class="language-javascript">// The death of a Subject
const subject = new Subject();
subject.subscribe(x =&gt; console.log(x));
subject.next(1); // 1
subject.next(2); // 2
subject.complete();
subject.next(3); // silently ignored
subject.unsubscribe();
subject.next(4); // Unhandled ObjectUnsubscribedError
</code></pre><p>在内部，每个 Subject 都维护着一个观察者注册表（作为一个数组）。简而言之，这就是 Subject 在内部的工作方式：</p><ul><li><p>每次有新的观察者订阅时，Subject 都会将观察者存储在观察者的数组中</p></li><li><p>当发出一个新值（即 next()调用该方法）时，Subject 将循环遍历观察者并向它们中的每一个发出相同的值（多播）。错误或完成时也会发生同样的情况</p></li><li><p>当一个 Subject 完成时，所有的观察者都会自动取消订阅</p></li><li><p>相反，当一个 Subject 被取消订阅时，订阅将仍然有效。观察者的数组被取消，但不会取消订阅它们。如果您尝试从未订阅的 Subject 发出值，它实际上会引发错误。最好的行动方案应该是在您需要处理它们及其观察者时完成您的 Subject ？？（没太懂这句话）</p></li><li><p>当其中一个观察者取消订阅时，它将从注册表中删除</p></li></ul><pre><code class="language-javascript">const subject = new Subject();
// add observer1 to the list of observers
const sub1 = subject.subscribe(observer1);
// add observer2 to the list of observers
const sub2 = subject.subscribe(observer2);
// notify all observers in the list with &quot;hi there&quot;
subject.next(&quot;hi there&quot;);
// remove observer1 from the list
sub1.unsubscribe();
</code></pre><h3>BehaviorSubject</h3><p>它有一个“当前值”的概念。它保存了发送给消费者的最新值。并且当有新的观察者订阅时，会立即从 BehaviorSubject 那接收到“当前值”。
BehaviorSubject 必须传入一个初始化的值</p><h3>ReplaySubject</h3><p>ReplaySubject 类似于 BehaviorSubject，它可以发送旧值给新的订阅者，但它还可以记录 Observable 执行的一部分。</p><p><strong>ReplaySubject 记录 Observable 执行中的多个值并将其回放给新的订阅者。</strong></p><p>ReplaySubject 在实例化的时候接受两个参数，第一个表示缓冲数量，第二个表示 window time (以毫秒为单位)来确定多久之前的值可以记录.</p><h3>AsyncSubject</h3><p>只有当 Observable 执行完成时(执行 complete())，它才会将执行的最后一个值发送给观察者。</p><h2>Scheduler (调度器)</h2><p>调度器控制着何时启动 subscription 和何时发送通知
目前还没有使用到过</p><blockquote><p>调度器可以让你规定 Observable 在什么样的执行上下文中发送通知给它的观察者。</p></blockquote><p><a href="https://cn.rx.js.org/manual/overview.html#h17">调度器相关</a></p><h2>Q&amp;A</h2><ol><li>multicast(new Subject()) 和 multicast(()=&gt;new Subject())的区别</li></ol><p>前者将一个冷的 observable 转化为一个热的 observable；后者实际上每次都会生成一个新的 Subject，在有新的订阅者来临时（在和 refCount 配合使用时，因为 refCount 会在有新的订阅者出现时使用 connect 开始共享的执行），如果前一个 subject 已经 complete 的话，那么就会重新生成一个 Subject，所以后者还是会接收到值。因此后者还是一个冷的 observable，多播一般使用前者。</p><p>口说无凭，看例子</p><ul><li>multicast(new Subject())</li></ul><pre><code class="language-javascript">var source = from([1, 2, 3]);
var multicasted = source.pipe(multicast(new Subject()), refCount());

// 在底层使用了 `subject.subscribe({...})`:
multicasted.subscribe({
  next: v =&gt; console.log(&quot;observerA: &quot; + v)
});
setTimeout(() =&gt; {
  multicasted.subscribe({
    next: v =&gt; console.log(&quot;observerB: &quot; + v)
  });
}, 200);

// multicasted.connect()
</code></pre><p>上面这种写法，无论是使用 refCount 还是手动 connect 结果都一样</p><pre><code class="language-text">observerA: 1
observerA: 2
observerA: 3
</code></pre><ul><li>multicast(()=&gt;new Subject()) + refCount() === share()</li></ul><pre><code class="language-javascript">var source = from([1, 2, 3]);
var multicasted = source.pipe(
  multicast(() =&gt; new Subject()),
  refCount()
);

// 在底层使用了 `subject.subscribe({...})`:
multicasted.subscribe({
  next: v =&gt; console.log(&quot;observerA: &quot; + v)
});
setTimeout(() =&gt; {
  multicasted.subscribe({
    next: v =&gt; console.log(&quot;observerB: &quot; + v)
  });
}, 200);
</code></pre><p>结果</p><pre><code class="language-text">
observerA: 1
observerA: 2
observerA: 3
observerB: 1
observerB: 2
observerB: 3
</code></pre><ul><li>multicast(()=&gt;new Subject()) + 手动 connect</li></ul><pre><code class="language-javascript">var source = from([1, 2, 3]);
var multicasted = source.pipe(multicast(() =&gt; new Subject()));

// 在底层使用了 `subject.subscribe({...})`:
multicasted.subscribe({
  next: v =&gt; console.log(&quot;observerA: &quot; + v)
});
setTimeout(() =&gt; {
  multicasted.subscribe({
    next: v =&gt; console.log(&quot;observerB: &quot; + v)
  });
}, 200);
multicasted.connect();
</code></pre><p>结果</p><pre><code class="language-text">observerA: 1
observerA: 2
observerA: 3
</code></pre><ol start="2"><li>publish().refCount() 或 share()的效果</li></ol><p>同时接通的多个订阅者不会重复触发上游的逻辑；但全部取消订阅之后再接通，就会再走一遍上游 (重订阅)； 因此并不是严格意义上的“缓存”</p><h2>推荐阅读</h2><ul><li><a href="https://blog.bitsrc.io/rxjs-subjects-in-depth-56dcfc1dc858">rxjs-subjects-in-depth</a></li><li><a href="https://www.digitalocean.com/community/tutorials/rxjs-subjects">how to use Subjects</a></li><li><a href="https://benlesh.medium.com/on-the-subject-of-subjects-in-rxjs-2b08b7198b93">关于 RxJS Subject 一些误用场景的介绍</a></li><li><a href="https://zhuanlan.zhihu.com/p/33621290">如何使用 refCount</a></li><li><a href="https://zhuanlan.zhihu.com/p/33225623">publish 和 share</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅的修改第三方包]]></title>
        <id>patch-package</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/patch-package"/>
        <updated>2021-12-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[官方介绍]]></summary>
        <content type="html"><![CDATA[<h2>官方介绍</h2><p>patch-package 给开发者提供了通过打“补丁”的方式，使得重新安装依赖包时能够保留之前对第三方依赖包的修改的一种解决方案。</p><h2>应用场景</h2><p>我们在使用第三方依赖包时如果遇到了 bug，通常解决的方式都是绕过这个问题，使用其他方式解决，较为麻烦。或者给作者提个 issue 或者 PR，然后等待作者的修复。等待的时间不可控，此时就可以借助 patch-package 自己动手去修复该 bug，感觉是不是很棒。并且还可以在第三方依赖包上，根据业务需求扩展能力。</p><blockquote><p>最好还是扩展一些通用性比较高的能力，如果是比较通用且该能力大多数开发者都有这种诉求的话可以给第三方依赖包提个 PR。</p></blockquote><h2>使用方法</h2><h3>安装</h3><p>都是在项目里自行安装</p><h4>npm</h4><pre><code class="language-bash">npm i patch-package
</code></pre><h4>yarn</h4><pre><code class="language-bash">yarn add patch-package postinstall-postinstall
</code></pre><h4>为什么 yarn 要添加 postinstall-postinstall 包</h4><p>yarn 在 yarn、yarn install 和 yarn add <code>&lt;package&gt;</code> 之后运行 postinstall 脚本，但在 yarn remove <code>&lt;package&gt;</code> 之后不运行。如果您将此包添加到您的项目中，即使在 yarn remove <code>&lt;package&gt;</code> 之后，它也会执行您项目的 postinstall 钩子。这需要你的 postinstall 脚本是幂等的，因为它会为 yarn、yarn install 和 yarn add <code>&lt;package&gt;</code> 运行两次</p><h3>修改 package.json</h3><p>依赖包在安装完之后会执行 postinstall 命令</p><pre><code class="language-json">&quot;scripts&quot;: {
    ***,
+   &quot;postinstall&quot;: &quot;patch-package&quot;
}
</code></pre><h3>修改依赖包源码</h3><h3>生成补丁</h3><pre><code class="language-bash">yarn patch-package package-name(修改的包名)
# 或者
npx patch-package package-name（npm版本 &gt; 5.2）
</code></pre><p>执行<code>npx patch-package antd</code>结果</p><pre><code class="language-bash">npx patch-package antd
Need to install the following packages:
  patch-package
Ok to proceed? (y) y
patch-package 6.4.7
• Creating temporary folder
• Installing antd@4.17.3 with yarn
• Diffing your files with clean files
✔ Created file patches/antd+4.17.3.patch

💡 antd is on GitHub! To draft an issue based on your patch run

    yarn patch-package antd --create-issue

</code></pre><p>可以看到patch-package已经为我们创建了一个补丁。</p><p>默认会在我们的根目录下创建一个patches文件夹。在patches文件夹下会创建依赖包名+版本号.patch的文件，文件描述了我们修改了什么，第几行，有点像git的提交记录。</p><pre><code class="language-text">diff --git a/node_modules/antd/lib/button/button.js b/node_modules/antd/lib/button/button.js
index da5fc9a..7eec125 100644
--- a/node_modules/antd/lib/button/button.js
+++ b/node_modules/antd/lib/button/button.js
@@ -143,40 +143,40 @@ var InternalButton = function InternalButton(props, ref) {
   var _classNames;
 
   var _props$loading = props.loading,
-      loading = _props$loading === void 0 ? false : _props$loading,
-      customizePrefixCls = props.prefixCls,
-      type = props.type,
-      danger = props.danger,
-      _props$shape = props.shape,
-      shape = _props$shape === void 0 ? &#x27;default&#x27; : _props$shape,
-      customizeSize = props.size,
-      className = props.className,
-      children = props.children,
-      icon = props.icon,
-      _props$ghost = props.ghost,
-      ghost = _props$ghost === void 0 ? false : _props$ghost,
-      _props$block = props.block,
-      block = _props$block === void 0 ? false : _props$block,
-      _props$htmlType = props.htmlType,
-      htmlType = _props$htmlType === void 0 ? &#x27;button&#x27; : _props$htmlType,
-      rest = __rest(props, [&quot;loading&quot;, &quot;prefixCls&quot;, &quot;type&quot;, &quot;danger&quot;, &quot;shape&quot;, &quot;size&quot;, &quot;className&quot;, &quot;children&quot;, &quot;icon&quot;, &quot;ghost&quot;, &quot;block&quot;, &quot;htmlType&quot;]);
+    loading = _props$loading === void 0 ? false : _props$loading,
+    customizePrefixCls = props.prefixCls,
+    type = props.type,
+    danger = props.danger,
+    _props$shape = props.shape,
+    shape = _props$shape === void 0 ? &#x27;default&#x27; : _props$shape,
+    customizeSize = props.size,
+    className = props.className,
+    children = props.children,
+    icon = props.icon,
+    _props$ghost = props.ghost,
+    ghost = _props$ghost === void 0 ? false : _props$ghost,
+    _props$block = props.block,
+    block = _props$block === void 0 ? false : _props$block,
+    _props$htmlType = props.htmlType,
+    htmlType = _props$htmlType === void 0 ? &#x27;button&#x27; : _props$htmlType,
+    rest = __rest(props, [&quot;loading&quot;, &quot;prefixCls&quot;, &quot;type&quot;, &quot;danger&quot;, &quot;shape&quot;, &quot;size&quot;, &quot;className&quot;, &quot;children&quot;, &quot;icon&quot;, &quot;ghost&quot;, &quot;block&quot;, &quot;htmlType&quot;]);
 
   var size = React.useContext(_SizeContext[&quot;default&quot;]);
 
   var _React$useState = React.useState(!!loading),
-      _React$useState2 = (0, _slicedToArray2[&quot;default&quot;])(_React$useState, 2),
-      innerLoading = _React$useState2[0],
-      setLoading = _React$useState2[1];
+    _React$useState2 = (0, _slicedToArray2[&quot;default&quot;])(_React$useState, 2),
+    innerLoading = _React$useState2[0],
+    setLoading = _React$useState2[1];
 
   var _React$useState3 = React.useState(false),
-      _React$useState4 = (0, _slicedToArray2[&quot;default&quot;])(_React$useState3, 2),
-      hasTwoCNChar = _React$useState4[0],
-      setHasTwoCNChar = _React$useState4[1];
+    _React$useState4 = (0, _slicedToArray2[&quot;default&quot;])(_React$useState3, 2),
+    hasTwoCNChar = _React$useState4[0],
+    setHasTwoCNChar = _React$useState4[1];
 
   var _React$useContext = React.useContext(_configProvider.ConfigContext),
-      getPrefixCls = _React$useContext.getPrefixCls,
-      autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton,
-      direction = _React$useContext.direction;
+    getPrefixCls = _React$useContext.getPrefixCls,
+    autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton,
+    direction = _React$useContext.direction;
 
   var buttonRef = ref || /*#__PURE__*/React.createRef();
   var delayTimeoutRef = React.useRef();
@@ -218,10 +218,11 @@ var InternalButton = function InternalButton(props, ref) {
   React.useEffect(fixTwoCNChar, [buttonRef]);
 
   var handleClick = function handleClick(e) {
+    console.log(234567) // 我的修改
     var _a;
 
     var onClick = props.onClick,
-        disabled = props.disabled; // https://github.com/ant-design/ant-design/issues/30207
+      disabled = props.disabled; // https://github.com/ant-design/ant-design/issues/30207
 
     if (innerLoading || disabled) {
       e.preventDefault();
</code></pre><h3>测试补丁是否有效</h3><ul><li>手动删除node_modules文件夹，重新执行yarn安装依赖包。可以看到在依赖包安装结束后执行了patch-package命令，之前生成的补丁被应用了。因为我们配置了postinstall脚本，所以会自动执行patch-package命令</li></ul><pre><code class="language-bash">$ patch-package
patch-package 6.4.7
Applying patches...
antd@4.17.3 ✔
✨  Done in 3.32s.
</code></pre><ul><li>查看node-modules中之前修改的antd修改的地方，查看之前修改的代码是否还存在。如果之前修改的代码还存在，说明补丁文件已经生效了，如果不存在，排查下是否哪个步骤出现了问题。</li></ul><p>antd/lib/button/button.js</p><pre><code class="language-javascript">  var handleClick = function handleClick(e) {
    console.log(234567) // Ops! 存在
    var _a;

    var onClick = props.onClick,
      disabled = props.disabled; // https://github.com/ant-design/ant-design/issues/30207

    if (innerLoading || disabled) {
      e.preventDefault();
      return;
    }

    (_a = onClick) === null || _a === void 0 ? void 0 : _a(e);
  };
</code></pre><p><strong>最后将patches文件夹推送到远端仓库，日后无论是谁拉取代码，安装依赖，我们之前修改的部分都会生效的</strong></p><h2>注意事项</h2><ol><li><p>patch是锁定版本号的，如果升级了版本，patch内容将会失效，最好在package.json能够锁定版本号。</p></li><li><p>魔改的同时，也局限了升级的能力，尽量还是去提issue和PR。</p></li></ol>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 yarn 你需要知道的]]></title>
        <id>about-yarn</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/about-yarn"/>
        <updated>2021-12-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[重要：永远不要手动去修改 yarn.lock 文件]]></summary>
        <content type="html"><![CDATA[<p><strong>重要：永远不要手动去修改 yarn.lock 文件</strong></p><p><strong>重要：永远不要手动去修改 package.json 文件，如果你需要使用一个包的最新版本，可以使用 <code>yarn upgrade</code> 命令来去升级该 package，它会自动安装最新版本并且更新 yarn.lock 文件</strong></p><p><strong>重要：永远不要随便的就去删除 node_modules 文件和 yarn.lock 文件去重新 install，因为它可能会更新一些你并不想更新的包，而带来一些难以预料的问题</strong></p><h2>registry</h2><p>其实就是查询下载每个模块的源。</p><p>当我们执行 <code>yarn install</code> 时候，就是去 <code>registry</code> 查询得到 package 压缩包地址进行下载的。</p><pre><code class="language-bash">yarn config get registry # 查看当前使用的源
</code></pre><pre><code class="language-bash">yarn config set registry url # 设置源
</code></pre><h2>依赖版本</h2><p>yarn 的包遵守语义化版本，格式为</p><pre><code class="language-text">X.Y.Z（主版本号.次版本号.修订号）：
X.主版本号：进行不向下兼容的修改时，递增主版本号
Y.次版本号: 做了向下兼容的新增功能或修改
Z.修订号：做了向下兼容的问题修复
</code></pre><h3>版本号：~version</h3><p>表示主版本号和次版本号相同，修订号取最新</p><table><thead><tr><th>表示</th><th>含义</th></tr></thead><tbody><tr><td>~3.1.4</td><td>&gt;=3.1.4 &lt;3.2.0</td></tr><tr><td>~3.1</td><td>3.1.x 或 &gt; = 3.1.0 &lt; 3.2.0</td></tr><tr><td>~3</td><td>3.x 或 &gt; = 3.0.0 &lt; 4.0.0</td></tr></tbody></table><h3>版本号：^version</h3><p>表示主版本号相同，取最新版本</p><p>使用 <code>yarn add package</code>时，默认使用的是 ^ 范围。</p><h2>依赖类型</h2><h3>dependencies</h3><p>代码运行时所需要的依赖，比如 vue，vue-router。</p><h3>devDependencies</h3><p>开发依赖，就是那些只在开发过程中需要，而运行时不需要的依赖，比如 babel，webpack。</p><h3>peerDependencies</h3><p>同伴依赖，它用来告知宿主环境需要什么依赖以及依赖的版本范围。如果宿主环境没有对应版本的依赖，在安装依赖时会报出警告。</p><h3>optionalDependencies</h3><p>可选依赖，这种依赖即便安装失败，Yarn 也会认为整个依赖安装过程是成功的。可选依赖适用于那些即便没有成功安装可选依赖，也有后备方案的情况。</p><h3>bundledDependencies</h3><p>打包依赖，在发布包时，这个数组里的包都会被打包打包到最终的发布包里，需要注意 <code>bundledDependencies</code> 中的包必须是在 <code>devDependencies</code> 或 <code>dependencies</code> 声明过的。</p><h2>缓存</h2><p><code>yarn</code> 会将安装过的包缓存下来，<strong>这样再次安装相同包的时候，就不需要再去下载，而是直接从缓存文件中直接 copy 进来</strong>。</p><p>可以通过命令 <code>yarn cache dir</code> 查看 yarn 的全局缓存目录。</p><p>yarn 会将不通版本解压后的包存放在不同目录下，目录以</p><pre><code class="language-text">npm-[package name]-[version]-[shasum]`
</code></pre><p><code>shasum</code>是一个 hash 值，在 lock 和缓存时会使用到。</p><p>我们可以通过命令查看已经缓存过的包。</p><pre><code class="language-bash">yarn cache list    列出已缓存的每个包

yarn cache list --pattern &lt;pattern&gt;  列出匹配指定模式的已缓存的包
</code></pre><h2>yarn.lock</h2><p><code>yarn.lock</code> 中会准确的存储每个依赖的具体版本信息，以保证在不同机器安装可以得到相同的结果。</p><h3>yarn.lock 的作用</h3><p>不要轻易的删除 yarn.lock 文件。</p><p>把 yarn.lock 删掉后，原本锁住的版本都放开了，执行 yarn install 的时候会根据 package.json 里定义的版本区间去找最新版。所以，可能会造成你预期外的依赖也被更新了，不幸的话可能会引入 bug。</p><p><strong>锁定唯一版本</strong></p><ul><li>package.json 里定义的是版本区间，如^1.0.0</li><li>而 yarn.lock 里的 version 字段是唯一的版本号，如 1.0.0</li></ul><pre><code class="language-text">ajax-hook@^2.0.3:
  version &quot;2.0.3&quot;
  resolved &quot;http://npm.zhenguanyu.com/ajax-hook/download/ajax-hook-2.0.3.tgz#e9ceced02f940f6223123c7dc90fe2062d417c18&quot;
  integrity sha1-6c7O0C+UD2IjEjx9yQ/iBi1BfBg=

&quot;@utilts/z@^0.2.57&quot;, &quot;@utilts/z@^0.2.58&quot;:
  version &quot;0.2.58&quot;
  resolved &quot;http://npm.zhenguanyu.com/@utilts/z/download/@utilts/z-0.2.58.tgz#df1ad9c27734e4efd18095d49239dede266bea1f&quot;
  integrity sha1-3xrZwnc05O/RgJXUkjne3iZr6h8=
  dependencies:
    &quot;@utilts/zdata&quot; &quot;^0.2.58&quot;
    lodash-es &quot;^4.17.21&quot;
    query-string &quot;^6.11.1&quot;
    rxjs &quot;^6.6.7&quot;
</code></pre><ul><li><p>第一行 <code>ajax-hook@^2.0.3</code> 包的 name 和语义化版本号，这些都来自 package.json 中的定义。也被称为 <code>Identifier(s)</code>，多个 Identifier 最终可能都指向同一个版本</p></li><li><p>version 记录的是一个确定的版本，也就是实际安装的版本</p></li><li><p>resolved 字段记录的是包的 URL 地址。其中 hash 值，即上文的<code>shasum</code></p></li><li><p>integrity 是对 resolved 下载下来的文件进行完整性校验。如果出现 diff，说明同一个下载链接对应的文件被修改过。</p></li><li><p>dependencies 字段记录的是当前包的依赖，即当前包在自己的 package.json 的 dependencies 字段中的所有依赖。</p></li></ul><p>Yarn 在安装期间，只会使用当前项目的 yarn.lock 文件，会忽略任何依赖里面的 yarn.lock 文件。在顶级 yarn.lock 中包含需要锁定的整个依赖树里全部包版本的所有信息。</p><p><strong>yarn.lock 文件是在安装期间，由 Yarn 自动生成的，并且由 yarn 来管理，不应该手动去更改，更不应该删除 yarn.lock 文件，且要提交到版本控制系统中，以免因为不同机器安装的包版本不一致引发问题。</strong></p><p>我们的常规操作(yarn add / yarn upgrade)都会自动更新 package.json 和 yarn.lock</p><h3>package.json 中的 resolutions 选项</h3><p><strong>通过这个选项可以修改 yarn.lock 中某个 package 的版本</strong></p><p>假如你的项目依赖了 foo,foo 依赖了 bar@^1.0.0。假设 bar 现在有两个版本 1.0.0 和 1.1.0。很不幸，bar 在发布 1.1.0 的时候没有做好向后兼容。导致 foo 和 <a href="mailto:bar@1.1.0">bar@1.1.0</a> 不能搭配使用。如果你可以等：</p><ul><li>要么等 foo 把依赖 bar 锁成 1.0.0 并重新发版</li><li>要么等 bar 修复兼容问题后重新发版</li></ul><p>那如果你等不了呢，你已知 foo 和 <a href="mailto:bar@1.0.0">bar@1.0.0</a> 可以正常工作。如果你能锁住 foo 对 bar 的依赖就好了，但是这定义在 foo 的 packge.json 里，你总不能去改 node_modules/foo/package.json 吧？这不合适。resolutions 可以解决你的问题，只要在你自己项目的 package.json 里定义：</p><pre><code class="language-json">&quot;resolutions&quot;: {
  &quot;foo/bar&quot;: &quot;1.0.0&quot;
}
</code></pre><p>这里的 key&quot;foo/bar&quot;表示 foo 的直接依赖 bar，把版本区间重写成 1.0.0。如果 foo 不是直接依赖的 bar（foo -&gt; ... -&gt; bar），我还需要把中间的链路都捋清楚吗？不用那么麻烦！</p><pre><code class="language-json">&quot;resolutions&quot;: {
  &quot;foo/**/bar&quot;: &quot;1.0.0&quot;
}
</code></pre><p>如果你的项目里有很多依赖直接/间接的依赖了 bar，每个定义的版本区间可能有差别，你知道某个版本可以让他们都能正常工作，而不用安装多个版本。也可以不用声明前缀部分，只写包名 bar。这样不管是哪里依赖到了 bar 都会指向你声明的哪个版本。</p><pre><code class="language-json">&quot;resolutions&quot;: {
  &quot;bar&quot;: &quot;1.0.0&quot;
}
</code></pre><p>执行 yarn install 后，在 yarn.lock 里搜索 bar@：</p><pre><code class="language-text">bar@^1.0.0 bar@1.1.0 bar@^2.0.0:
  version &quot;1.0.0&quot;
  ...
</code></pre><p><strong>可以看到，resolutions 可以违背版本区间的限制，比如上例中 Identifiers 里的 <a href="mailto:bar@1.1.0">bar@1.1.0</a>``bar@^2.0.0。</strong></p><h3>yarn --frozen-lockfile / npm ci</h3><p>即使有 lock file 的存在，也无法保证在持续集成环境中每次安装依赖都和开发时一致，因为可能存在 package.json 和 lockfile 版本号不匹配并需要更新依赖版本的情况。可以使用--frozen-lockfile 来避免。</p><p>这两个命令的作用类似，必须存在 lock file 且依赖版本和 package.json 匹配时才会安装依赖，否则报错。如此可强制开发者在持续集成前先在本地解决依赖版本的一致性问题。</p><h2>yarn install 的过程</h2><p>首次执行 yarn install 安装，会按照 package.json 中的语义化版本，去向 registry 进行查询，并获取到符合版本规则的最新的依赖包进行下载，并构建构建依赖关系树。 比如在 package.json 中指定 react 的版本为 ^2.0.0，就会获取符合 2.x.x
的最高版本的包。然后自动生成 yarn.lock 文件，并生成缓存。</p><p>之后再执行 yarn install，会对比 package.json 中依赖版本范围和 yarn.lock 中版本号是否匹配。</p><ul><li><p>版本号匹配：会根据 yarn.lock 中的 resolved 字段去查看缓存， 如果有缓存，直接 copy，没有缓存则按照 resolved 字段的 url 去下载包。</p></li><li><p>版本号不匹配：根据 package.json 中的版本范围去 registry 查询，下载符合版本规则最新的包，并更新至 yarn.lock 中。</p></li></ul><h2>模块扁平化</h2><p>假设我项目的首层依赖(即当前项目的 dependence 和 devDependences 中的依赖，不包括依赖的依赖)中有 A，B，C 三个包，A 和 B 包同时依赖了相同版本范围的 D 包。那么这部分的依赖关系树是这样的：</p><pre><code class="language-text">├── A
│ └── D
├── B
│ └── D
├── C
</code></pre><p>如果按照这样的依赖关系树直接安装的话，D 模块会在 A 包和 B 包的 node_modules 中都安装，这样会导致模块冗余。</p><p>为了保证依赖关系树中没有大量重复模块，yarn 在安装时会做 dedupe（去重）操作，它会遍历所有节点，逐个将模块放在根节点下面，也就是当前项目的 node-modules 中。当发现有相同的模块时，会判断当前模块指定的版本范围是否交集，如果有，则只保留兼容版本，如果没有则在当前的包的 node-modules 下安装。</p><p>所以上面的说的情况，最终安装完成是下面这样的，A，B，C，D 包都会安装在第一层 node-modules 下（在依赖的 D 版本兼容的情况下）。</p><pre><code class="language-text">├── A
├── B
├── C
├── D
</code></pre><p>如果 A 包和 B 包依赖的是不兼容的版本，假设 A 包依赖的是 D@1 版本的包，B 包依赖的是 D@2 版本。则最终安装的结果如下：</p><pre><code class="language-text">├── A
├── B
│ └── D@2
├── C
├── D@1
</code></pre><p>至于是 D 的那个版本被安装在根目录的 node_modules 下，取决的是模块解析的顺序，先解析到的 D 的指定版本会被安装到根 node_modules，后解析到的 D 且不兼容已有版本时，会被安装到对应模块的 node_modules 下</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[硬链接和符号链接]]></title>
        <id>hard-link-and-symbolic-link</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/hard-link-and-symbolic-link"/>
        <updated>2021-12-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Linux 的链接概念]]></summary>
        <content type="html"><![CDATA[<h2>Linux 的链接概念</h2><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。</p><p>通俗一点理解，可以把硬链接当成源文件的副本，他和源文件一样的大小但是事实上却不占任何空间。
符号链接可以理解为类似 windows 一样的快捷方式。</p><h2>硬链接</h2><p>硬连接指通过索引节点来进行连接。
在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。
在 Linux 中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。
硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><pre><code class="language-bash">ln existfile  newfile # 创建硬链接
</code></pre><p>硬链接文件有两个限制</p><ul><li>不允许给目录创建硬链接</li><li>只允许在同一文件系统中的文件之间才能创建链接</li></ul><p>对于硬链接文件进行读写和删除操作的时候，结果和符号链接相同。但是如果我们删除硬链接文件的源文件，硬链接文件仍存在，而且保留了原有的内容。</p><h2>符号链接</h2><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，这个文件包含了另一个文件的路径名。
可以是任意文件或目录，也可以链接不同文件系统的文件。甚至可以链接不存在的文件，这就产生一般称为“断裂”的问题（现象），还可以不断的循环链接自己。
在对符号链接进行读写操作的时候，系统会自动把该操作转换为对源文件的操作。但是删除链接文件时，系统仅仅删除符号链接文件，而不删除源文件本身。</p><pre><code class="language-bash">ln -s source_file  softlink_file # 创建符号链接
</code></pre><h2>实验一下</h2><pre><code class="language-bash">$ touch f1          #创建一个测试文件f1
$ ln f1 f2          #创建f1的一个硬连接文件f2
$ ln -s f1 f3       #创建f1的一个符号连接文件f3
$ ls -li            # -i参数显示文件的inode节点信息
total 0
7722708 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1
7722708 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2
7722757 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&gt; f1
</code></pre><p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 7722708，然而符号连接文件的 inode 节点不同。</p><pre><code class="language-text">$ echo &quot;I am f1 file&quot; &gt;&gt;f1
$ cat f1
I am f1 file
$ cat f2
I am f1 file
$ cat f3
I am f1 file
$ rm -f f1
$ cat f2
I am f1 file
cat f3
cat: f3: No such file or directory
</code></pre><p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效</p><h2>硬链接和符号链接的区别</h2><ul><li>硬链接仅能链接文件，而符号链接可以链接目录</li><li>硬链接在链接完成后仅和文件内容关联，和之前链接的文件没有任何关系。而符号链接始终和之前链接的文件关联，和文件内容不直接相关。</li></ul><h2>总结</h2><ul><li><p>删除符号连接 f3,对 f1,f2 无影响；</p></li><li><p>删除硬连接 f2，对 f1,f3 也无影响；</p></li><li><p>删除原文件 f1，对硬连接 f2 没有影响，导致符号连接 f3 失效；</p></li><li><p>同时删除原文件 f1,硬连接 f2，整个文件会真正的被删除。</p></li></ul><p>符号链接（symbolic link）在建立的时候建立了一个新的 inode，并记录了指向源文件 inode 的路径。所以 symbolic 的 inode number 跟原始档案的 inode number 是不一样的。这也是为什么 symbolic link 能够跨越不同文件系统的原因。
符号链接建立了新的 inode number，所以它是一个真实的文件并占有一定的磁盘空间。另外对 symbolic link 的操作除了删除都会直接对源文件进行操作。</p><p>hard link 的 inode number 跟源文件的 inode number 是一样的。因为一个文件系统有着相同的 inode number，所以 hard link 是不可以跨文件系统创建的。也可以将 hard link 理解为不是一个文件，把它看成是同一个 inode 的别名，建立 hard link 后他和源文件互为别名，删除其中任何一个，inode 都不会释放。只有指向同一 inode 的文件名都删除后，inode 才释放。hard link 实际上是不占空间的。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 line-height 属性]]></title>
        <id>line-height</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/line-height"/>
        <updated>2021-12-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- 没给元素设置高度时，元素高度采用的是 line-height 的高度，这个属性具有继承性。也自带默认值，所以当你给一个没有设置高度的元素设置 line-height:0;即使里面有文本，它也是会塌陷的。]]></summary>
        <content type="html"><![CDATA[<ul><li><p>没给元素设置高度时，元素高度采用的是 line-height 的高度，这个属性具有继承性。也自带默认值，所以当你给一个没有设置高度的元素设置 line-height:0;即使里面有文本，它也是会塌陷的。</p></li><li><p>可以分为好几种盒子，当你设置 line-height 的时候，行内框是不会变化的，改变的是行距，它只由 font-size 的决定。这其实就是上边元素 height 等于 line-height 的时候，元素内文本会垂直居中的原因。</p></li><li><p>取值为 number 时，line-height 为 number 乘以当前元素的 font-size,取 normal 时一般就是 number 为 1.2</p></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[peerDependencies]]></title>
        <id>peerDependencies</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/peerDependencies"/>
        <updated>2021-12-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[为什么会研究这个 peerDependencies？]]></summary>
        <content type="html"><![CDATA[<h2>为什么会研究这个 peerDependencies？</h2><p>因为我在我们的组的组件库的<code>package.json</code>中看到了这个，然后我就发现这里面的依赖都是在我们项目中中也需要使用的。
而且我们的组件库是基于 angular 的，但是它并没有将 angular 作为 dependencies。
然后我又去看了看一些第三方的组件库或者是插件，我发现他们都没有将一些核心库（react、vue、angular、jquery）作为直接依赖，而是只是将他们添加到了 peerDependencies 中，这让我想知道，peerDependencies 到底是干什么的？</p><h2>我们希望我们使用的插件或者是第三方库对于和项目中共同的依赖有什么表现呢？</h2><p>在我开发的 packageA 里面依赖的 react 和 react-dom 的版本号应该和主系统中安装的 react 和 react-dom 的版本号保持一致，并且 packageA 被安装到主系统中之后，就应该依赖于主系统中的 react 和 react-dom。</p><h2>说说 peerDependencies</h2><p>同等依赖，或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本。用于解决插件与所依赖包不一致的问题。</p><p><code>peerDependencies</code> 在我们进行一些插件开发的时候会经常用到，比如 antd 的开发依赖于 React</p><p>总结一下特点：</p><ul><li><p>插件正确运行的前提是，核心依赖库必须先下载安装，不能脱离核心依赖库而被单独依赖并引用；</p></li><li><p>插件入口 api 的设计必须要符合核心依赖库的规范；</p></li><li><p>插件的核心逻辑运行在依赖库的调用中；</p></li><li><p>在项目实践中，同一插件体系下，核心依赖库版本最好是相同的；</p></li></ul><p>听起来可能没有那么好理解，举个例子来说明下。antd 只是提供了一套基于 react 的 ui 组件库，但它要求宿主环境需要安装指定的 react 版本，所以你可以看到 node_modules 中 antd 的 package.json 中有这么一项配置:</p><pre><code class="language-json">&quot;peerDependencies&quot;: {
    &quot;react&quot;: &quot;&gt;=16.0.0&quot;,
    &quot;react-dom&quot;: &quot;&gt;=16.0.0&quot;
},
</code></pre><p>它要求宿主环境安装大于等于 16.0.0 版本的 react，也就是 antd 的运行依赖宿主环境提供的该范围的 react 安装包。</p><blockquote><p>在安装插件的时候，peerDependencies 在 npm 2.x 和 npm 3.x 中表现不一样。npm2.x 会自动安装同等依赖，npm3.x 不再自动安装，会产生警告！手动在 package.json 文件中添加依赖项可以解决。</p></blockquote><p>当别人使用我们的插件时，<code>peerDependencies</code>就会告诉明确告诉使用方，你需要安装该插件哪个宿主版本。
通常情况下，我们会在一个项目里使用一个宿主（比如 gulp）的很多插件，如果相互之间存在宿主不兼容，在执行<code>npm install</code>时，cli 会抛出错误信息来告诉我们，比如：</p><pre><code class="language-text">npm ERR! peerinvalid The package gulp does not satisfy its siblings&#x27; peerDependencies requirements!
npm ERR! peerinvalid Peer gulp-cli-config@0.1.3 wants gulp@~3.1.9
npm ERR! peerinvalid Peer gulp-cli-users@0.1.4 wants gulp@~2.3.0
</code></pre><p>当你安装一个包时，其 dependencies 和 devDependencies 会被 npm 自动安装。</p><p>peerDependencies 则有所不同，它们不会被自动安装。</p><p>当一个依赖项 c 被列在某个包 b 的 peerDependency 中时，它就不会被自动安装。取而代之的是，包含了 b 包的代码库 a 则必须将对应的依赖项 c 包含为其依赖。</p><h3>举例说说</h3><p>假设现在有一个 <code>helloWorld</code> 工程,已经在其 <code>package.json</code> 的 <code>dependencies</code> 中声明了 <code>packageA</code>，有两个插件 <code>plugin1</code> 和 <code>plugin2</code> 他们也依赖 <code>packageA</code>，如果在插件中使用 <code>dependencies</code> 而不是 <code>peerDependencies</code> 来声明 <code>packageA</code>，那么 <code>$ npm install</code> 安装完 <code>plugin1</code> 和 <code>plugin2</code> 之后的依赖图是这样的：(前提是依赖的 packageA 的版本都不同)</p><pre><code class="language-text">.
├── helloWorld
│   └── node_modules
│       ├── packageA
│       ├── plugin1
│       │   └── nodule_modules
│       │       └── packageA
│       └── plugin2
│       │   └── nodule_modules
│       │       └── packageA
</code></pre><p>从上面的依赖图可以看出，<code>helloWorld</code> 本身已经安装了一次<code>packageA</code>，但是因为因为在
<code>plugin1</code> 和 <code>plugin2</code> 中的 <code>dependencies</code> 也声明了 <code>packageA</code>，所以最后 <code>packageA</code> 会被安装三次，有两次安装是冗余的。</p><p><strong>需要注意的是 npm 现在对于依赖版本相同的包会在 install 的时候自动扁平化（npm v3 之后是这么做的），也就是说，当多个 package 依赖了相同的包且他们的版本也相同的时候，仅仅会在项目的根 node_modules 下安装一份</strong></p><p>而 <code>peerDependency</code> 就可以避免类似的<strong>核心依赖库</strong>被重复下载的问题。</p><p>如果在 <code>plugin1</code> 和 <code>plugin2</code> 的 <code>package.json</code> 中使用 <code>peerDependency</code> 来声明核心依赖库，例如：</p><p>plugin1/package.json</p><pre><code class="language-json">{
  &quot;peerDependencies&quot;: {
    &quot;packageA&quot;: &quot;1.0.1&quot;
  }
}
</code></pre><p>plugin2/package.json</p><pre><code class="language-json">{
  &quot;peerDependencies&quot;: {
    &quot;packageA&quot;: &quot;1.0.1&quot;
  }
}
</code></pre><p>在主系统中声明一下 packageA:</p><p>helloWord/package.json</p><pre><code class="language-json">{
  &quot;dependencies&quot;: {
    &quot;packageA&quot;: &quot;1.0.1&quot;
  }
}
</code></pre><p>此时在主系统中执行 <code>$ npm install</code> 生成的依赖图就是这样的：</p><pre><code class="language-text">.
├── helloWorld
│   └── node_modules
│       ├── packageA
│       ├── plugin1
│       └── plugin2
</code></pre><p>可以看到这时候生成的依赖图是扁平的，packageA 也只会被安装一次。</p><p>总结下在插件使用 <code>peerDependency</code> 声明依赖库的特点：</p><ul><li>如果用户显式依赖了核心库，则可以忽略各插件的 <code>peerDependency</code> 声明；</li><li>如果用户没有显式依赖核心库，则按照插件 <code>peerDependencies</code> 中声明的版本将库安装到项目根目录中；</li><li>当用户依赖的版本、各插件依赖的版本之间不相互兼容，会报错让用户自行修复；</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pnpm又是什么？]]></title>
        <id>pnpm</id>
        <link href="https://guoxiaxing.github.io/Blog/blog/pnpm"/>
        <updated>2021-12-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[为什么有 pnpm？]]></summary>
        <content type="html"><![CDATA[<h2>为什么有 pnpm？</h2><h3>节约磁盘空间并提升安装速度 ​</h3><p>当使用 npm 或 Yarn 时，如果你有 100 个项目使用了某个依赖，就会有 100 份该依赖的副本保存在硬盘上。 对于 pnpm ，依赖项将存储在一个内容可寻址的仓库中，因此：</p><ul><li><p>如果你用到了某依赖项的不同版本，那么只会将有差异的文件添加到仓库。 例如，如果某个包有 100 个文件，而它的新版本只改变了其中 1 个文件。那么 pnpm update 时只会向存储中心额外添加 1 个新文件，而不会因为仅仅一个文件的改变复制整新版本包的内容。</p></li><li><p>所有文件都会存储在硬盘上的某一位置。 当软件包被被安装时，包里的文件会硬链接到这一位置，而不会占用额外的磁盘空间。 这允许你跨项目地共享同一版本的依赖。</p></li></ul><h3>创建非扁平化的 node_modules 文件夹 ​</h3><p>当使用 npm 安装依赖时，所有的依赖都会被提升到模块的根目录。 因此，项目可以访问到未被添加进当前项目的依赖。</p><p>pnpm 使用软链的方式将项目的直接依赖添加进模块文件夹的根目录。</p><h2>依赖管理</h2><h3>hard link 机制</h3><p>hard link 使得用户可以通过不同的路径引用方式去找到某个文件。pnpm 会在<strong>全局的 store 目录里存储项目 node_modules 文件的 hard links</strong> 。</p><p>所以全局的 store 中存放的是我们所有项目依赖的包的信息的 hard links，用于在二次下载的时候进行版本的检测</p><p>关于什么是硬连接和软链接，可以看看我的另一篇文章：<a href="https://guoxiaxing.github.io/Blog/blog/hard-link-and-symbolic-link">硬链接和符号链接</a></p><h3>Store 目录</h3><p>一般 store 目录默认是设置在 \${os.homedir}/.pnpm-store 这个目录下
当然用户也可以在 .npmrc 设置这个 store 目录位置，不过一般而言 store 目录对于用户来说感知程度是比较小的。
因为这样一个机制，导致每次安装依赖的时候，如果是个相同的依赖，有好多项目都用到这个依赖，那么这个依赖实际上最优情况(即版本相同)只用安装一次。
如果是 npm 或 yarn，那么这个依赖在多个项目中使用，在每次安装的时候都会被重新下载一次。
pnpm 对项目安装依赖的时候，如果某个依赖在 sotre 目录中存在了话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。</p><h3>node_modules 结构</h3><p>pnpm 目前的 node_modules 的一些文件结构，例如在项目中使用 pnpm 安装了一个叫做 express 的依赖，那么最后会在 node_modules 中形成这样两个目录结构:</p><pre><code class="language-text">node_modules/express/...
node_modules/.pnpm/express@4.17.1/node_modules/xxx
</code></pre><p>其中第一个路径是 nodejs 正常寻找路径会去找的一个目录，如果去查看这个目录下的内容，会发现里面连个 node_modules 文件都没有：</p><pre><code class="language-text">▾ express
    ▸ lib
      History.md
      index.js
      LICENSE
      package.json
      Readme.md
</code></pre><p>实际上这个文件只是个软连接，它会形成一个到第二个目录的一个软连接(类似于软件的快捷方式)，这样 node 在找路径的时候，最终会找到 .pnpm 这个目录下的内容。
其中这个 .pnpm 是个虚拟磁盘目录，然后 <strong>express 这个依赖的一些依赖</strong>会被平铺到 .pnpm/<a href="mailto:express@4.17.1">express@4.17.1</a>/node_modules/ 这个目录下面（包括 express 本身），这样保证了依赖能够 require 到，同时也不会形成很深的依赖层级。在保证了 nodejs 能找到依赖路径的基础上，同时也很大程度上保证了依赖能很好的被放在一起。
<strong>也就是说项目依赖的包的依赖包只会在.pnpm/包名/node_modules/下（但是还是只会安装一份，只要是多个依赖包的依赖是版本相同的，只会安装一个包，每个.pnpm/包名/node_modules/存放的其实是一个全局 store 中对应包源代码的 hard link），不会再被扁平化到根 node_modules 下，避免了一个不是项目显示依赖的包但是我们却可以使用的问题（即幽灵依赖）</strong></p><p><strong>总结一下：✏️ 对于 pnpm 的 node_modules 下的包名下存放的其实是一个软链接，连接到 node_modules 下的.pnpm/包名/node_modules/xxx 该目录下存放的是该依赖包的依赖以及该依赖包本身，每个包里面都存放了一个全局 store 中对应包源代码的 hard link。每个项目的 node_modules 下都存放的是一些 link</strong></p><h3>symlink 和 hard link 机制</h3><p>在前面知道了 pnpm 是通过 hardlink 在全局里面搞个 store 目录来存储 node_modules 依赖里面的 hard link 地址，然后在引用依赖的时候则是通过 symlink 去找到对应虚拟磁盘目录下(.pnpm 目录)的依赖地址。
pnpm 的 node_modules 布局使用符号链接来创建依赖项的嵌套结构。
node_modules 中每个包的每个文件都是来自内容可寻址存储的硬链接。
假设您安装了依赖于 <a href="mailto:bar@1.0.0">bar@1.0.0</a> 的 <a href="mailto:foo@1.0.0">foo@1.0.0</a>。 pnpm 会将两个包硬链接到 node_modules 如下所示：
foo 将被符号链接至根目录的 node_modules 文件夹，因为 foo 是项目的依赖项</p><p><a href="https://pnpm.io/zh/symlinked-node-modules-structure">链接过程</a></p><pre><code class="language-text">node_modules
├── foo -&gt; ./.pnpm/foo@1.0.0/node_modules/foo
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -&gt; &lt;store&gt;/bar
    └── foo@1.0.0
        └── node_modules
            ├── foo -&gt; &lt;store&gt;/foo
            └── bar -&gt; ../../bar@1.0.0/node_modules/bar
</code></pre><p>让我们添加 <a href="mailto:qar@2.0.0">qar@2.0.0</a> 作为 bar 和 foo 的依赖项。 这是新的结构的样子：</p><pre><code class="language-text">node_modules
├── foo -&gt; ./.pnpm/foo@1.0.0/node_modules/foo
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       ├── bar -&gt; &lt;store&gt;/bar
    │       └── qar -&gt; ../../qar@2.0.0/node_modules/qar
    ├── foo@1.0.0
    │   └── node_modules
    │       ├── foo -&gt; &lt;store&gt;/foo
    │       ├── bar -&gt; ../../bar@1.0.0/node_modules/bar
    │       └── qar -&gt; ../../qar@2.0.0/node_modules/qar
    └── qar@2.0.0
        └── node_modules
            └── qar -&gt; &lt;store&gt;/qar
</code></pre><p>而这些真实依赖则是通过 hard link 存储到全局的 store 目录中。</p><h2>兼容问题</h2><p>像 hard link 和 symlink 这种方式在所有的系统上都是兼容的吗？</p><p>实际上 hard link 在主流系统上(Unix/Win)使用都是没有问题的，但是 symlink 即软连接的方式可能会在 windows 存在一些兼容的问题，但是针对这个问题，pnpm 也提供了对应的解决方案，这里不做叙述。</p><h2>Monorepo 支持</h2><h3>痛点解决</h3><h4>幽灵依赖</h4><p>解释起来很简单，即某个包没有被安装(package.json 中并没有，但是用户却能够引用到这个包)。</p><p>引发这个现象的原因一般是因为 node_modules 结构所导致的，例如使用 yarn 对项目安装依赖，依赖里面有个依赖叫做 foo，foo 这个依赖同时依赖了 bar，yarn 会对安装的 node_modules 做一个扁平化结构的处理(npm v3 之后也是这么做的)，会把依赖在 node_modules 下打平，这样相当于 foo 和 bar 出现在同一层级下面。那么根据 nodejs 的寻径原理，用户能 require 到 foo，同样也能 require 到 bar。</p><pre><code class="language-text">package.json -&gt; foo(bar 为 foo 依赖)
node_modules
  /foo
  /bar -&gt; 幽灵依赖
</code></pre><p>那么这里这个 bar 就成了一个幽灵依赖，如果某天某个版本的 foo 依赖不再依赖 bar 或者 foo 的版本发生了变化，那么 require bar 的模块部分就会抛错。</p><p>还有一种场景就是在 lerna + yarn workspace 的项目里面，因为 yarn 中提供了 hoist 机制(即一些底层子项目的依赖会被提升到顶层的 node_modules 中)，这种 幽灵依赖 会更多，一些底层的子项目经常会去 require 一些在自己里面没有引入的依赖，而直接去找顶层 node_modules 的依赖(nodejs 这里的寻径是个递归上下的过程)并使用。</p><p>而根据前面提到的 pnpm 的 node_modules 依赖结构，这种现象是显然不会发生的，因为被打平的依赖会被放到 .pnpm 这个虚拟磁盘目录下面去，用户通过 require 是根本找不到的。</p><blockquote><p>值得一提的是，pnpm 本身其实也提供了将依赖提升并且按照 yarn 那种形式组织的 node_modules 结构的 Option，作者将其命名为 --shamefully-hoist ，即 &quot;羞耻的 hoist&quot;.....</p></blockquote><h4>NPM doppelgangers（分身）</h4><p>这个问题其实也可以说是 hoist 导致的，这个问题可能会导致有大量的依赖的被重复安装，举个例子:</p><p>例如有个 package，下面依赖有 lib_a、lib_b、lib_c、lib_d，其中 a 和 b 依赖 <a href="mailto:util_e@1.0.0">util_e@1.0.0</a>，而 c 和 d 依赖 <a href="mailto:util_e@2.0.0">util_e@2.0.0</a>。</p><pre><code class="language-text">- package
- package.json
- node_modules
- lib_a
  - node_modules &lt;- util_e@1.0.0
- lib_b
  - node_modules &lt;- util_e@1.0.0
_ lib_c
  - node_modules &lt;- util_e@2.0.0
- lib_d
  - node_modules &lt;- util_e@2.0.0
</code></pre><p>这样必然会导致很多依赖被重复安装，于是就有了 hoist 和打平依赖的操作:</p><pre><code class="language-text">- package
- package.json
- node_modules
- util_e@1.0.0
- lib_a
- lib_b
_ lib_c
  - node_modules &lt;- util_e@2.0.0
- lib_d
  - node_modules &lt;- util_e@2.0.0
</code></pre><p>但是这样也只能提升一个依赖，如果两个依赖都提升了会导致冲突，这样同样会导致一些不同版本的依赖被重复安装多次，这里就会导致使用 npm 和 yarn 的性能损失。</p><p>如果是 pnpm 的话，这里因为依赖始终都是存在 store 目录下的 hard links ，一份不同的依赖始终都只会被安装一次，因此这个是能够被彻彻底底的消除的。</p>]]></content>
    </entry>
</feed>