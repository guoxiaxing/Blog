---
slug: basic
title: 基础概念
tags: [React]
---

## state 和生命周期

有时候我们希望可以更新组件的数据，此时我们就需要借助state。state是每个组件自己私有的，完全受控于组件本身 

### 定义一个class组件来使用state

```tsx
class Clock extends Component<object, { time: Date }> {
  timer: null | number;
  // highlight-start
  constructor(props) {
    super(props);
    this.timer = null;
    this.state = {
      time: new Date(),
    };
  }
  // highlight-end

  componentDidMount() {
    this.timer = setInterval(() => {
      this.setState({ time: new Date() });
    }, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    return <div>{this.state.time.toLocaleString()} </div>;
  }
}
```

:::tip 知识点

1. 在构造函数中初始化state

2. 始终使用props参数来调用父类构造函数

3. 在构造函数中使用this之前必须调用super函数

4. componentDidMount 方法会在组件渲染到 DOM 中后运行，渲染到 DOM 中 && 渲染到页面之前，它中的操作会阻塞页面的渲染

5. componentWillUnmount 会在组件卸载之前执行，可以在这里执行一些清除的操作

6. 尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流的额外字段。

7. render 方法的返回值定义组件如何展示

8. setState() 的调用，React 能够知道 state 已经改变了，然后会重新调用 render() 方法

:::


:::caution useEffect(fn, []) 和 componentDidMount 的区别

- useEffect(fn, [])会在commit阶段执行完成之后异步的调用fn函数
- componentDidMount会在commit的mutation阶段完成组件更新之后的layout阶段**同步**调用，此时组件还没有被渲染在页面上

可见他们的**调用时机**完全不同 

而useLayoutEffect(fn,[])它的调用时机和componentDidMount完全一致也会在layout阶段同步调用 

:::

:::caution commit阶段

commit阶段的作用就是将状态变化渲染到视图中也就是将effect渲染到视图中，将commit阶段分为三个子阶段
- 渲染视图前 before mutation阶段
- 渲染视图 mutation阶段 --- placement effect会在该阶段执行DOM的插入操作，在layout阶段调用componentDidMount 
- 渲染视图后 layout阶段 

:::

### 正确的使用state

#### 不要直接修改state

```tsx
this.state.xxx = 123
```
tis.state上的xxx属性的值被改变了，但是React并不会重新渲染页面。应该使用 this.setState 来修改 state 

**构造函数唯一可以对this.state赋值的地方**

#### state的更新可能是异步的

无论是使用react hook的`useState`的`setState`还是使用class组件的`this.setState`的方式来更新state，我们都无法在更新state之后立即拿到最新的state

出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。

因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。

要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：

```javascript
this.setState((state, props) => ({
  c: state.a + props.b
}));
```

#### State 的更新会被合并（仅限this.setState）

当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。

**useState hook不会对传入的对象和当前的state进行合并，所以我们每次更新是需要保证传入了完整的state**

### 数据是向下流动的

React采用的是“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。

## 事件处理

React中的事件和DOM事件很类似，只有几点不同：

- 事件名称采用小驼峰命名法（onclick(DOM) -> onClick(React)）
- 在JSX中需要传入一个函数作为事件处理函数，而不是一个字符串
- 在React中不能通过返回false的方式来阻止默认事件，需要显示的调用e.preventDefault()

例如

1. 事件处理函数的绑定

```html
<button onclick="activateLasers()">
  Activate Lasers
</button>
```

```jsx
<button onClick={activateLasers}>
  Activate Lasers
</button>
```

2. 阻止默认行为

```html
<a href="#" onclick="console.log('The link was clicked.'); return false">
  Click me
</a>
```

```jsx
function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
  }

  return (
    <a href="#" onClick={handleClick}>
      Click me
    </a>
  );
}
```

:::tip 

1. 在这里，e 是一个合成事件。React 替我们处理了事件对象 event 对于不同浏览器的兼容性问题。

2. 在React中，我们一般不需要使用 addEventListener 来为 DOM 添加事件处理函数
:::

### 在类组件中绑定事件处理函数

```jsx
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(state => ({
      isToggleOn: !state.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

ReactDOM.render(
  <Toggle />,
  document.getElementById('root')
);
```

:::tip 

在类组件中，为事件处理函数绑定this是必不可少的，否则事件处理函数中的this指向的就不是组件实例，**而是undefined**

这个其实是 JS 函数的特性：

我们都知道JavaScript函数中的this不是在函数声明的时候定义的，而是在函数调用（即运行）的时候定义的

onClick 调用 handleClick 函数的时候，默认情况下，this 是指向全局的。但是，在 class 中默认使用严格模式，不会默认绑定，所以打印出来的 this 就是 undefined

:::

```javascript
class Foo {
  constructor(name){
    this.name = name
  }
  display(){
    console.log(this.name);
  }
}
var foo = new Foo('coco');
foo.display(); // coco

// 下面例子类似于在 React Component 中 handle 方法当作为回调函数传参
var display = foo.display;
display() // TypeError: this is undefined
```

我们在实际 React 组件例子中，假设 handleClick 方法没有通过 bind 绑定，this 的值为 undefined, 它和上面例子类似handleClick 也是作为回调函数传参形式。 但是我们代码不是在 strict 模式下, 为什么 this 的值不是全局对象，就像前面的 default binding,而是undefined？ 因为class内部默认是严格模式。

[原文链接](https://zhuanlan.zhihu.com/p/54962688)

对于事件处理函数的this我们有三种处理方式：

1. 在constructor中为事件处理函数绑定this ✅

2. 事件处理函数使用箭头函数定义 ✅

3. 在为事件传递事件处理函数的时候绑定this（不推荐，因为每次组件重新渲染的时候都会创建一个新函数）❌

### 向事件处理函数传递参数

```jsx
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```
- 箭头函数

- bind方法

在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。**(通过bind传递的参数，事件对象是最后一个)**

## 条件渲染

React中的条件渲染和JavaScript中的条件判断相同。可以使用if语句/三元表达式/逻辑与来实现

### if语句

```jsx
function ShowInfo(props) {
  if (props.showName) {
    return 'Lily';
  } else {
    return '-';
  }
}

class App extends Component<AppProps, AppState> {
  constructor(props) {
    super(props);
    this.state = {
      name: 'React',
    };
  }

  render() {
    return <ShowInfo showName={false} />;
  }
}
```

### 与运算符 &&

通过花括号包裹代码，你可以在 JSX 中嵌入任何表达式。这也包括 JavaScript 中的逻辑与 (&&) 运算符。它可以很方便地进行元素的条件渲染。（对于undefined/null/true/false可以实现理想的为真时展示组件，为假时什么都不渲染。但是并不是所有的假值都可以达到理想效果）

例如
```jsx

0 && <div>a</div>

```
此时页面上就会展示0

在 JavaScript 中，true && expression 总是会返回 expression, 而 false && expression 总是会返回 false。

因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。

### 三目运算符

另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 condition ? true : false。

```jsx
render() {
  const isLoggedIn = this.state.isLoggedIn;
  return (
    <div>
      The user is <b>{isLoggedIn ? 'currently' : 'not'}</b> logged in.
    </div>
  );
}
```

当然也可以渲染组件，有一个分支为 null 时就可以不在页面上渲染任何东西

### 阻止条件渲染

null

在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。

**在组件的 render 方法中返回 null 并不会影响组件的生命周期。**

- React基础看完
- 复习一周内容
- 复习 class
- 复习useEffect(fn, []) 和 componentDidMount的区别
