---
slug: 排序算法
title: 排序算法
tags: [掘金小册, 前端算法和数据结构, 排序算法]
---

- 基础排序算法：
  - 冒泡排序
  - 插入排序
  - 选择排序
- 进阶排序算法
  - 归并排序
  - 快速排序

## 冒泡排序 - 稳定的排序

将数组中的每两个相邻的元素进行比较，如果发现前一个元素大于后一个元素，那么就交换位置，这样第一轮遍历结束之后，数组的最后一个元素就是数组中最大的元素，那么在下一轮循环中最后一个元素就不参与比较。重复上面的方式，直到整个数组都变为有序

假如数组的长度是 n，那么当我们重复完 n 轮的时候，整个数组就有序了。

不过，冒泡排序的逻辑并不会因为数组有序就立刻停下来——”从头到尾遍历数组，对比+交换每两个相邻元素“这套逻辑到底要执行多少次，是完全由数组中元素的个数来决定的

```javascript
function bubbleSort(nums) {
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < len - i - 1; j++) {
      if (nums[j] > nums[j + 1]) {
        [nums[j], nums[j + 1]] = [nums[j + 1], nums[j]];
      }
    }
  }
  return nums;
}
```

上面这种写法，在最好情况下对应的时间复杂度确实不是 O(n)，而是 O(n^2)。

### 面向“最好情况”的进一步改进

```javascript
function bubbleSort(nums) {
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    // 区别在这里，我们加了一个标志位
    let flag = false;
    for (let j = 0; j < len - i - 1; j++) {
      if (nums[j] > nums[j + 1]) {
        [nums[j], nums[j + 1]] = [nums[j + 1], nums[j]];
        // 只要发生了一次交换，就修改标志位
        flag = true;
      }
    }
    // 若一次交换也没发生，则说明数组有序，直接放过
    if (flag == false) return nums;
  }
  return nums;
}
```

标志位可以帮助我们在第一次冒泡的时候就定位到数组是否完全有序，进而节省掉不必要的判断逻辑，将最好情况下的时间复杂度定向优化为 O(n)。

### 冒泡排序的时间复杂度

- 最好时间复杂度：它对应的是数组本身有序这种情况。在这种情况下，我们只需要作比较（n-1 次），而不需要做交换。时间复杂度为 O(n)
- 最坏时间复杂度： 它对应的是数组完全逆序这种情况。在这种情况下，每一轮内层循环都要执行，重复的总次数是 n(n-1)/2 次，因此时间复杂度是 O(n^2)
- 平均时间复杂度：这个东西比较难搞，它涉及到一些概率论的知识。实际面试的时候也不会有面试官摁着你让你算这个，这里记住平均时间复杂度是 O(n^2) 即可。

## 选择排序 - 不稳定的排序

将数组看为两部分，一部分是有序的，一部分是无序的，每次都从无序的那部分中选出最小的元素，然后追加到有序的这部分的末尾

```javascript
function selectSort(nums) {
  const len = nums.length;
  for (let i = 0; i < len; i++) {
    let minIndex = i;
    for (let j = i; j < len; j++) {
      if (nums[j] < nums[minIndex]) {
        minIndex = j;
      }
    }
    if (i !== minIndex) {
      [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
  }
  return nums;
}
```

### 选择排序的时间复杂度

最好情况也好，最坏情况也罢，两者之间的区别仅仅在于元素交换的次数不同，但都是要走内层循环作比较的。因此选择排序的三个时间复杂度都对应两层循环消耗的时间量级： O(n^2)。

## 插入排序 - 稳定排序

将数组看为两部分，一部分是有序的，一部分是无序的，每次都取出无序部分的第一个元素，在有序的那部分中从后往前查找，直到找到一个元素的值 <= 当前元素，则将当前元素插入到整个元素后面

插入排序里的几个关键点：

- 当前元素前面的那个序列是有序的
- “正确的位置”如何定义——所有在当前元素前面的数都不大于它，所有在当前元素后面的数都不小于它
- 在有序序列里定位元素位置的时候，是从后往前定位的。只要发现一个比当前元素大的值，就需要为当前元素腾出一个新的坑位。

```javascript
function insertSort(nums) {
  const len = nums.length;
  for (let i = 1; i < len - 1; i++) {
    let j = i;
    for (; j > 0; j--) {
      if (nums[j - 1] > nums[j]) {
        nums[j] = nums[j - 1];
      } else {
        break;
      }
    }
    nums[j] = nums[i];
  }
  return nums;
}
```

### 插入排序的时间复杂度

- 最好时间复杂度：它对应的数组本身就有序这种情况。此时内层循环只走一次，整体复杂度取决于外层循环，时间复杂度就是一层循环对应的 O(n)。

- 最坏时间复杂度：它对应的是数组完全逆序这种情况。此时内层循环每次都要移动有序序列里的所有元素，因此时间复杂度对应的就是两层循环的 O(n^2)

- 平均时间复杂度：O(n^2)
