---
slug: 真题训练
title: 真题训练
tags: [掘金小册, 前端算法和数据结构, 真题训练]
---

## 最长回文子串

### 中心扩散

```javascript
function longestPalindrome(s) {
  const len = s.length;
  let res = '';
  if (len < 2) return s;
  for (let i = 0; i < len; i++) {
    if (len % 2 === 0) {
      // 长度为奇数
      helper(i, i);
    } else {
      // 长度为偶数
      helper(i, i + 1);
    }
  }

  function helper(i, j) {
    while (i >= 0 && j < len && s[i] === s[j]) {
      i--;
      j++;
    }
    if ((j - 1) - (i + 1) + 1 > res.length) {
      res = s.slice(i + 1, j)
    }
  }

  return res;
}
```

### 动态规划

题干中的“最长”二字，表明了这是一道“求最值”型问题。前面我们说过，看到最值，就要把动态规划调度进可用解题工具里。

继续往下分析，发现这道题中，较长回文子串中可能包含较短的回文子串（最优子结构）

我们拿到的原始素材是一个字符串序列，符合“序列型”动态规划的特征。大家现在已经知道，对于序列型动态规划，我们总是需要以它的索引为线索去构造一维或二维的状态数组。对于这道题来说，由于定位任意子串需要的是两个索引，因此我们的状态数组应该是一个二维数组：

```javascript
// 初始化一个二维数组
let dp = [];
const len = s.length
for (let i = 0; i < len; i ++) {
    dp[i] = [];
};
```

由于i和j分别表示子串的两个端点，只要我们明确了这两个值，就能间接地求出子串的长度。因此dp[i][j]不必额外记录长度这个状态，只需要记录该区间内的字符串是否回文。这里我们把回文记为 1（或true），不回文记为0（或false）。

按照这个思路走下去，我们需要关注到的无疑就是字符串的两个端点 s[i]和s[j]了。当遍历到一对新的端点的时候，有以下两种可能的状态转移情况：

1. s[i] === s[j]。这种情况下，只要以 s[i+1]和s[j-1]为端点的字符串是回文字符串，那么 dp[i][j] = 1 就成立，否则 dp[i][j] = 0。
2. s[i] !== s[j]。这种情况下，一定有 dp[i][j]=0。

到这里，我们也就明确到了这道题的状态转移方程，这里我用编码表达如下：

```javascript
if(s[i] === s[j]) {
    dp[i][j] = dp[i+1][j-1]  
} else {
    dp[i][j] = 0
}
```

找出了状态转移方程，现在来找边界值。这里大家需要注意的是：**如果在一个序列中，涉及到了 i、j两个索引，那么一定要关注到 i===j 这种特殊情况。**在这道题中，由于 i===j时，dp[i][i]对应的是一个单独的字母，单独的字母必然回文（长度为1），因此dp[i][i] = 1 就是这道题的边界值（或者说初始值）。

```javascript
function longestPalindrome(s) {
  const len = s.length;
  if (len < 2) return s;
  const dp = [];
  for (let i = 0; i < len; i++) {
    dp[i] = [];
  }
  // 初始化最长回文子串的两个端点值
  let st = 0, end = 0
  // 初始化最长回文子串的初始值为1
  for (let i = 0; i < len; i++) {
    dp[i][i] = 1
  }
  // 这里为了降低题目的复杂度，我们预先对悬念比较小的 s[i][i+1] 也做了处理
  for (let i = 0; i < len - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = 1;
      st = i;
      end = i + 1;
    }
  }

  // n 代表子串的长度，从3开始递增
  for (let n = 3; n <= len; n++) {
    // 下面的两层循环，用来实现状态转移方程
    for (let i = 0; i <= len - n; i++) {
      let j = i + n - 1
      if (dp[i + 1][j - 1]) {
        if (s[i] === s[j]) {
          // 若定位到更长的回文子串，则更新目标子串端点的索引值
          dp[i][j] = 1
          st = i
          end = j
        }
      }
    }
  }
  // 最后依据端点值把子串截取出来即可
  return s.substring(st, end + 1);
}
```

## 从前序（先序）与中序遍历序列构造二叉树

> 题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。

前序序列当前范围的头部索引记为 preL，尾部索引记为 preR；把中序序列当前范围的头部索引记为 inL，尾部索引记为 inR

根结点(p1)在中序序列中的坐标索引为 k，于是左子树的结点个数就可以通过计算得出：

```text
numLeft = k - 1
```

那么左子树在前序序列中的索引区间就是 [preL+1,preL+numLeft]，在中序序列中的索引区间是 [inL, k-1]；右子树在前序序列的索引区间是 [preL+numLeft+1, preR]，在中序序列中的索引区间是 [k+1, inR]。

```javascript
function buildTree(preOrder, inOrder) {
  const len = preOrder.length;
  function build(preL, preR, inL, inR) {
    if (preL > preR || inL > inR) return null;
    const root = new TreeNode();
    root.val = preOrder[preL];
    const k = inOrder.indexOf(root.val);
    const numLeft = k - inL;
    root.left = build(preL + 1, preL + numLeft, inL, k - 1);
    root.right = build(preL + numLeft + 1, preR, k + 1, inR);
    return root;
  }
  return build(0, len - 1, 0, len - 1);
}
```

## 从后序（先序）与中序遍历序列构造二叉树

```javascript
function buildTree(inOrder, postOrder) {
  const len = inOrder.length;
  function build(inL, inR, postL, postR) {
    if (inL > inR || postL > postR) return null;
    const root = new TreeNode(postOrder[postR]);
    const k = inOrder.indexOf(root.val);
    const numLeft = k - inL;
    root.left = build(inL, k - 1, postL, postL + numLeft - 1);
    root.right = build(k + 1, inR, postL + numLeft, postR)
    return root;
  }
  return build(0, len - 1, 0, len - 1);
}
```

## 复制带随机指针的链表

> 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。

```javascript
function copyRandomList(head) {
  // 处理边界条件
  if (!head) return null
  // 初始化copy的头部结点
  let copyHead = new Node()
  // 初始化copy的游标结点
  let copyNode = copyHead
  // 初始化hashMap
  const hashMap = new Map()
  let curr = head
  // 首次循环，正常处理链表的复制
  while (curr) {
    copyNode.val = curr.val;
    copyNode.next = curr.next ? new Node() : null;
    // 存储原节点和对应的copy节点的关系，用于random节点的拷贝 !!!!
    hashMap.set(curr, copyNode);
    curr = curr.next;
    copyNode = copyNode.next;
  }

  // 将游标复位到head
  curr = head
  // 将copy链表的游标也复位到copyHead
  copyNode = copyHead
  // 再搞个循环，特殊处理random关系
  while (curr) {
    copyNode.random = curr.random ? hashMap.get(curr.random) : null;
    curr = curr.next;
    copyNode = copyNode.next;
  }
  return copyHead;
}
```

## 岛屿数量问题

> 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

每座岛屿只能由水平或竖直方向上相邻的陆地连接而成。

若当前所在位置是1，从1出发，可以抵达的**所有**1都和它算作同一个岛屿。

> 看到“所有”，必须想到“枚举”！看到“枚举”，必须回忆起DFS和BFS！

1. 岛屿的统计思路：从起点出发，遵循“不撞水面（也就是0）不回头”的原则，枚举当前可以触及的所有1。当枚举无法继续进行时，说明当前这座岛屿被遍历完毕，记为一个。也就是说每完成一次 DFS，就累加一个岛屿。
2. 避免重复计算的方法：每遍历过一个1，就把它置为0，后续再次路过时就会自动忽略它啦

```javascript
function numIslands(grid) {
  // moveX[i], moveY[i] 表示对当前格子的 上下左右四个方向的遍历
  const moveX = [0, 0, -1, 1]
  const moveY = [-1, 1, 0, 0]
  if (!grid || !grid.length || !grid[0].length) {
    return 0
  }
  let count = 0;
  const row = grid.length, column = grid[0].length;
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < column; j++) {
      if (grid[i][j] === 1) {
        dfs(grid, i, j);
        // 每完成一个 dfs，就累加一个岛屿
        count++
      }
    }
  }

  function dfs(grid, i, j) {
    if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === 0) {
      return;
    }
    // 遍历过的坑位都置0，防止反复遍历
    grid[i][j] = 0
    // 遍历完当前的1，继续去寻找下一个1
    for (let k = 0; k < 4; k++) {
      dfs(grid, i + moveX[k], j + moveY[k])
    }
  }
  return count;
}
```

后续我们遇到的一些题目，一旦和这道题一样，强调了“水平”、“垂直”方向上的相邻关系，我们就可以无脑复用这个套路啦~

## “扫地机器人”问题

> 房间（用格栅表示）中有一个扫地机器人。格栅中的每一个格子有空和障碍物两种可能。

扫地机器人提供4个API，可以向前进，向左转或者向右转。每次转弯90度。

当扫地机器人试图进入障碍物格子时，它的碰撞传感器会探测出障碍物，使它停留在原地。

请利用提供的4个API编写让机器人清理整个房间的算法。

```text
interface Robot {
  // 若下一个方格为空，则返回true，并移动至该方格
  // 若下一个方格为障碍物，则返回false，并停留在原地
  boolean move();

  // 在调用turnLeft/turnRight后机器人会停留在原位置
  // 每次转弯90度
  void turnLeft();
  void turnRight();

  // 清理所在方格
  void clean();
}
```

```text
输入：

room = [
[1,1,1,1,1,0,1,1],
[1,1,1,1,1,0,1,1],
[1,0,1,1,1,1,1,1],
[0,0,0,1,0,0,0,0],
[1,1,1,1,1,1,1,1]
],
row = 1,
col = 3
```

房间格栅用0或1填充。0表示障碍物，1表示可以通过。 机器人从row=1，col=3的初始位置出发。在左上角的一行以下，三列以右。

### 思路分析

这道题涉及到对二维数组网格的枚举，可能与岛屿数量问题的基本思路一致（将DFS作为优先方法来考虑）。虽然我不知道对不对，但是沿着这个思路往下多分析几步总是好的：

1. 机器人从初始位置出发，检查上下左右四个方向是否有障碍物，进而决定是否进入对应方向的格子完成清扫。
2. 因为题目强调了“所有可抵达的格子都是相连的，亦即所有标记为1的格子机器人都可以抵达”，所以我们借助DFS尝试枚举所有可抵达的格子是完全没有问题的。DFS的主要递归逻辑其实就是步骤1。
3. 当某一个方向已经“撞到南墙”后，机器人应该逐渐回溯到上一个位置，尝试新的方向。
4. 最后，由于递归边界其实就是障碍物/已经清扫过的格子。所以别忘了对已经清扫过的格子做个标记。

假设机器人现在所在的格子坐标是 (i, j)，它的旋转角度以及对应的前进坐标之间就有以下关系（结合题意我们把“上”这个初始方向记为0度）：

```text
（定义逻辑）  
// 初始化角度为 0 度  
let dir = 0   
...   

（判断逻辑）
// 将角度和前进坐标对应起来
switch(dir) {
    // 0度的前进坐标，是当前坐标向上走一步
    case 0:   
        x = i - 1  
        break
    // 90度（顺时针）的前进坐标，是当前坐标向右走一步
    case 90: 
        y = j + 1   
        break
    // 180度（顺时针）的前进坐标，是当前坐标向下走一步
    case 180: 
        x = i + 1  
        break
    // 270度（顺时针）的前进坐标，是当前坐标向左走一步
    case 270: 
        y = j - 1
        break
    default:
        break
}
...
（叠加逻辑）
// 注意这里我给机器人的规则就是每次顺时针转一个方向，所以是 turnRight
robot.turnRight() 
// turnRight的同时，dir需要跟着旋转90度  
dir += 90  
// 这里取模是为了保证dir在[0, 360]的范围内变化
dir %= 360 
```

### 如何优雅地对已处理过的格子做标记

请思考一下，在这道题里，是否还可以沿用“岛屿数量”问题中直接修改二维数组的思路？说实话，没试过，也不建议——就这道题来说，题给的四个API都不是我们自己实现的，一旦改了全局的 room 变量，谁知道会影响哪个API呢。保险起见，我们应该优先考虑不污染room变量的实现方法，这里我借助的是 Set 数据结构：

```text
以下是定义逻辑）
//初始化一个 set 结构来存储清扫过的坐标
const boxSet =  new Set()  
...

（以下是判断逻辑）
// 标识当前格子的坐标
let box = i + '+' + j  
// 如果已经打扫过，那么跳过
if(boxSet.has(box)) return 
// 打扫当前这个格子
robot.clean()  
// 记住这个格子
boxSet.add(box)
```

```javascript
function cleanRoom(robot) {
  // 初始化一个 set 结构来存储清扫过的坐标
  const boxSet = new Set()
  // 初始化机器人的朝向
  let dir = 0
  // 进入 dfs
  dfs(robot, boxSet, 0, 0, 0)

  function dfs(robot, boxSet, i, j, dir) {
    // 记录当前格子的坐标
    let box = i + '+' + j
    // 如果已经打扫过，那么跳过
    if (boxSet.has(box)) return
    // 打扫当前这个格子
    robot.clean()
    // 记住这个格子
    boxSet.add(box)

    // 四个方向试探
    for (let k = 0; k < 4; k++) {
      // 如果接下来前进的目标方向不是障碍物（也就意味着可以打扫）
      if (robot.move()) {
        // 从当前格子出发，试探上右左下
        let x = i, y = j
        // 处理角度和坐标的对应关系
        switch (dir) {
          case 0:
            x = i - 1
            break
          case 90:
            y = j + 1
            break
          case 180:
            x = i + 1
            break
          case 270:
            y = j - 1
            break
          default:
            break
        }
        dfs(robot, boxSet, x, y, dir)
        // 一个方向的dfs结束了，意味着撞到了南墙，此时我们需要回溯到上一个格子 
        robot.turnLeft()
        robot.turnLeft()
        robot.move()
        robot.turnRight()
        robot.turnRight()
      }
      // 转向 
      robot.turnRight()
      dir += 90
      dir %= 360
    }
  }
}
```


### 编码复盘

```javascript
dfs(robot, boxSet, x, y, dir)
robot.turnLeft()
robot.turnLeft()
robot.move()
robot.turnRight()
robot.turnRight()
```

结合一下代码的上下文，这里我给机器人的设定是：

你在进入每一个格子后，都需要基于当前方向顺时针旋转四次

在这个前提下，机器人在 (x,y) 这个格子工作完之后，它的朝向一定是和刚进入 (x,y)时的朝向是一样的，区别在于在原来的基础上多走了一个格子

此时后一个网格的机器人要想退回“事前”的状态，它必须先旋转 180 度，然后前进一步，再旋转 180 度。而“旋转 180 度”这个动作，可以通过连续两次 turnLeft或者turnRight来完成。

## “合并区间”问题

> 给出一个区间的集合，请合并所有重叠的区间。

```text
示例

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```


```javascript
function merge(intervals) {
  // 定义结果数组
  const result = []
  // 处理区间的边界情况
  if (!intervals || !intervals.length) {
    return []
  }
  // 缓存区间个数
  const len = intervals.length
  // 将所有区间按照第一个元素大小排序
  intervals.sort(function (a, b) {
    return a[0] - b[0]
  })
  prev = intervals[0];
  for (let i = 1; i < len; i++) {
    cur = intervals[i]
    if (cur[0] <= prev[1]) {
      prev[1] = Math.max(cur[1], prev[1])
    } else {
      result.push(prev);
      prev = cur;
    }
  }
  result.push(prev);
  return result;
}
```