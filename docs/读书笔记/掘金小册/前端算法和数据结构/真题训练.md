---
slug: 真题训练
title: 真题训练
tags: [掘金小册, 前端算法和数据结构, 真题训练]
---

## 最长回文子串

### 中心扩散

```javascript
function longestPalindrome(s) {
  const len = s.length;
  let res = '';
  if (len < 2) return s;
  for (let i = 0; i < len; i++) {
    if (len % 2 === 0) {
      // 长度为奇数
      helper(i, i);
    } else {
      // 长度为偶数
      helper(i, i + 1);
    }
  }

  function helper(i, j) {
    while (i >= 0 && j < len && s[i] === s[j]) {
      i--;
      j++;
    }
    if ((j - 1) - (i + 1) + 1 > res.length) {
      res = s.slice(i + 1, j)
    }
  }

  return res;
}
```

### 动态规划

题干中的“最长”二字，表明了这是一道“求最值”型问题。前面我们说过，看到最值，就要把动态规划调度进可用解题工具里。

继续往下分析，发现这道题中，较长回文子串中可能包含较短的回文子串（最优子结构）

我们拿到的原始素材是一个字符串序列，符合“序列型”动态规划的特征。大家现在已经知道，对于序列型动态规划，我们总是需要以它的索引为线索去构造一维或二维的状态数组。对于这道题来说，由于定位任意子串需要的是两个索引，因此我们的状态数组应该是一个二维数组：

```javascript
// 初始化一个二维数组
let dp = [];
const len = s.length
for (let i = 0; i < len; i ++) {
    dp[i] = [];
};
```

由于i和j分别表示子串的两个端点，只要我们明确了这两个值，就能间接地求出子串的长度。因此dp[i][j]不必额外记录长度这个状态，只需要记录该区间内的字符串是否回文。这里我们把回文记为 1（或true），不回文记为0（或false）。

按照这个思路走下去，我们需要关注到的无疑就是字符串的两个端点 s[i]和s[j]了。当遍历到一对新的端点的时候，有以下两种可能的状态转移情况：

1. s[i] === s[j]。这种情况下，只要以 s[i+1]和s[j-1]为端点的字符串是回文字符串，那么 dp[i][j] = 1 就成立，否则 dp[i][j] = 0。
2. s[i] !== s[j]。这种情况下，一定有 dp[i][j]=0。

到这里，我们也就明确到了这道题的状态转移方程，这里我用编码表达如下：

```javascript
if(s[i] === s[j]) {
    dp[i][j] = dp[i+1][j-1]  
} else {
    dp[i][j] = 0
}
```

找出了状态转移方程，现在来找边界值。这里大家需要注意的是：**如果在一个序列中，涉及到了 i、j两个索引，那么一定要关注到 i===j 这种特殊情况。**在这道题中，由于 i===j时，dp[i][i]对应的是一个单独的字母，单独的字母必然回文（长度为1），因此dp[i][i] = 1 就是这道题的边界值（或者说初始值）。

```javascript
function longestPalindrome(s) {
  const len = s.length;
  if (len < 2) return s;
  const dp = [];
  for (let i = 0; i < len; i++) {
    dp[i] = [];
  }
  // 初始化最长回文子串的两个端点值
  let st = 0, end = 0
  // 初始化最长回文子串的初始值为1
  for (let i = 0; i < len; i++) {
    dp[i][i] = 1
  }
  // 这里为了降低题目的复杂度，我们预先对悬念比较小的 s[i][i+1] 也做了处理
  for (let i = 0; i < len - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = 1;
      st = i;
      end = i + 1;
    }
  }

  // n 代表子串的长度，从3开始递增
  for (let n = 3; n <= len; n++) {
    // 下面的两层循环，用来实现状态转移方程
    for (let i = 0; i <= len - n; i++) {
      let j = i + n - 1
      if (dp[i + 1][j - 1]) {
        if (s[i] === s[j]) {
          // 若定位到更长的回文子串，则更新目标子串端点的索引值
          dp[i][j] = 1
          st = i
          end = j
        }
      }
    }
  }
  // 最后依据端点值把子串截取出来即可
  return s.substring(st, end + 1);
}
```

## 从前序（先序）与中序遍历序列构造二叉树

> 题目描述：根据一棵树的前序遍历与中序遍历构造二叉树。

前序序列当前范围的头部索引记为 preL，尾部索引记为 preR；把中序序列当前范围的头部索引记为 inL，尾部索引记为 inR

根结点(p1)在中序序列中的坐标索引为 k，于是左子树的结点个数就可以通过计算得出：

```text
numLeft = k - 1
```

那么左子树在前序序列中的索引区间就是 [preL+1,preL+numLeft]，在中序序列中的索引区间是 [inL, k-1]；右子树在前序序列的索引区间是 [preL+numLeft+1, preR]，在中序序列中的索引区间是 [k+1, inR]。

```javascript
function buildTree(preOrder, inOrder) {
  const len = preOrder.length;
  function build(preL, preR, inL, inR) {
    if (preL > preR || inL > inR) return null;
    const root = new TreeNode();
    root.val = preOrder[preL];
    const k = inOrder.indexOf(root.val);
    const numLeft = k - inL;
    root.left = build(preL + 1, preL + numLeft, inL, k - 1);
    root.right = build(preL + numLeft + 1, preR, k + 1, inR);
    return root;
  }
  return build(0, len - 1, 0, len - 1);
}
```

## 从后序（先序）与中序遍历序列构造二叉树

```javascript
function buildTree(inOrder, postOrder) {
  const len = inOrder.length;
  function build(inL, inR, postL, postR) {
    if (inL > inR || postL > postR) return null;
    const root = new TreeNode(postOrder[postR]);
    const k = inOrder.indexOf(root.val);
    const numLeft = k - inL;
    root.left = build(inL, k - 1, postL, postL + numLeft - 1);
    root.right = build(k + 1, inR, postL + numLeft, postR)
    return root;
  }
  return build(0, len - 1, 0, len - 1);
}
```

## 复制带随机指针的链表

> 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。

```javascript
function copyRandomList(head) {
  // 处理边界条件
  if (!head) return null
  // 初始化copy的头部结点
  let copyHead = new Node()
  // 初始化copy的游标结点
  let copyNode = copyHead
  // 初始化hashMap
  const hashMap = new Map()
  let curr = head
  // 首次循环，正常处理链表的复制
  while (curr) {
    copyNode.val = curr.val;
    copyNode.next = curr.next ? new Node() : null;
    // 存储原节点和对应的copy节点的关系，用于random节点的拷贝 !!!!
    hashMap.set(curr, copyNode);
    curr = curr.next;
    copyNode = copyNode.next;
  }

  // 将游标复位到head
  curr = head
  // 将copy链表的游标也复位到copyHead
  copyNode = copyHead
  // 再搞个循环，特殊处理random关系
  while (curr) {
    copyNode.random = curr.random ? hashMap.get(curr.random) : null;
    curr = curr.next;
    copyNode = copyNode.next;
  }
  return copyHead;
}
```