---
slug: UDP和TCP
title: UDP 和 TCP
tags: [掘金小册, 前端面试之道, UDP和TCP]
---

## UDP

- 无连接
- 不可靠：不保证数据的顺序和完整性
- 没有流量控制

### 无连接

只是数据报文的搬运工，不会对数据报进行拆分和拼接工作

- 发送端，应用层将报文传递给传输层的UDP协议，UDP只会给报文增加一个UDP的首部标识一下是UDP协议，然后传递给网络层
- 接收端，网络层将数据传递给传输层的UDP协议，UDP去除UDP首部将数据传递给应用层

### 不可靠性

无连接、不关心对方是否正确的收到数据、没有流量控制，所以就会导致在网络拥塞的情况下可能会丢包

### 高效

- 首部大小较小，只有8个字节

16位源端口号

16位目的端口号

16位数据报文长度

16位数据报文校验和

### 传输方式

一对一、一对多、多对多、多对一

### 适用场景

实时性要求较高的场景

视频通话、语音、DNS

## TCP

- 面向连接
- 可靠数据传输
- 流量控制
- 首部20个字节

### 重要的首部

#### Seq

序列号：这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文

#### ACK

确认号：这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到

#### Window Size

窗口大小，表示还能接收多少字节的数据，用于流量控制

#### 标识符

- ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。

- SYN=1：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。

- FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。

### 三次握手

- C -> S: SYN=1,Seq=x
- S -> C: SYN=1,ACK=x+1,Seq=y
- C -> S: ACK=y+1

> 为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接?

> 防止无效的SYN报文到达服务端，导致服务端建立连接而浪费服务器资源。在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次

### 四次挥手

- C -> S: FIN=1,Seq
- S -> C: ACK=Seq+1

此时表明 C 到 S 的连接已经释放，不再接收 C 发的数据了。但是因为 TCP 连接是双向的，所以 S 仍旧可以发送数据给 C。

- S -> C: FIN=1,Seq
- C -> S: ACK=Seq+1

**客户端在发送确认报文之后不会立即关闭链接，会等待2*MSL之后再关闭连接，服务器在收到客户端的确认之后会立即关闭连接**

**原因：1. 保证在旧连接中产生的报文可以消失，新连接中不会出现旧连接中的报文；2. 保证服务端可以收到确认报文**

:::info

1. 保证客户端发送的最后一个ACK报文能够到达服务器。因为这个ACK报文可能会丢失，站在服务器的角度我已经发送了ACK+FIN报文请求断开了，客户端没有给我回应，应该是我发送的FIN+ACK报文客户端没有收到，那么我就会重新发送。那么这个客户端就可能在这个2MSL时间内收到这个重传的报文，然后重启2MSL定时器

2. 客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

:::
